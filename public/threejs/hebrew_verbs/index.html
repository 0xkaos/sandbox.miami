<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hebrew Verbs Galaxy - Roots Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
            z-index: 1000;
        }

        /* Top Bar */
        #top-bar {
            padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: auto;
        }

        /* Controls Panel */
        #controls-panel {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid #444;
            border-radius: 15px;
            padding: 15px 25px;
            display: flex; gap: 20px;
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(77, 184, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .control-group { display: flex; flex-direction: column; gap: 5px; }
        .control-label { font-size: 0.8em; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        
        select {
            background: #111; color: #fff; border: 1px solid #444;
            padding: 8px 12px; border-radius: 5px; font-size: 1em;
            outline: none; cursor: pointer; min-width: 120px;
        }
        select:hover { border-color: #4db8ff; }

        /* 3D Labels */
        .root-label {
            font-size: 24px; font-weight: bold; color: var(--root-color, #4db8ff);
            text-shadow: 0 0 10px rgba(77, 184, 255, 0.5);
            cursor: pointer; pointer-events: auto;
            transition: all 0.3s;
            user-select: none;
        }
        .root-label:hover { color: #fff; transform: scale(1.2); }
        .root-label.active { color: #fff; text-shadow: 0 0 20px #4db8ff; font-size: 32px; }

        .verb-label {
            font-size: 16px; color: #aaa;
            background: rgba(0,0,0,0.85);
            padding: 8px 12px; border-radius: 8px;
            border: 1px solid #333;
            cursor: default; pointer-events: auto;
            transition: all 0.2s;
            white-space: nowrap;
            text-align: center;
            display: flex; flex-direction: column; align-items: center; gap: 5px;
        }
        .verb-label:hover { 
            background: rgba(20, 20, 30, 0.95); 
            border-color: #4db8ff; color: white;
            z-index: 100;
        }
        .verb-sub { font-size: 0.8em; color: #888; display: block; margin-bottom: 5px; }
        
        .verb-actions {
            display: flex; gap: 8px; margin-top: 5px;
            opacity: 0.6; transition: opacity 0.2s;
        }
        .verb-label:hover .verb-actions { opacity: 1; }
        
        .verb-btn {
            background: rgba(255,255,255,0.1); border: 1px solid #555;
            color: #ddd; border-radius: 4px; padding: 4px 8px;
            cursor: pointer; font-size: 0.9em;
            transition: all 0.2s;
        }
        .verb-btn:hover { background: #4db8ff; color: #000; border-color: #4db8ff; }
        .verb-btn.play-btn { color: #4db8ff; border-color: #4db8ff; }
        .verb-btn.play-btn:hover { background: #4db8ff; color: white; }

        /* Info Panel (Right Side) */
        #info-panel {
            position: absolute; top: 80px; right: 20px; bottom: 100px;
            width: 350px;
            background: rgba(10, 10, 15, 0.95);
            border-left: 1px solid #333;
            padding: 20px;
            transform: translateX(110%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            overflow-y: auto;
            border-radius: 10px;
        }
        #info-panel.visible { transform: translateX(0); }

        #close-panel {
            position: absolute; top: 10px; right: 10px;
            background: none; border: none;
            color: #666; font-size: 24px; line-height: 1;
            cursor: pointer; padding: 5px;
            transition: color 0.2s;
            z-index: 10;
        }
        #close-panel:hover { color: #fff; }

        h1 { margin: 0; font-size: 1.5em; background: linear-gradient(45deg, #4db8ff, #b84dff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        /* Search */
        #search-box {
            background: rgba(0,0,0,0.5); border: 1px solid #444; color: white;
            padding: 8px; border-radius: 5px; width: 200px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="top-bar">
            <div>
                <h1> Hebrew Roots Helix</h1>
                <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">Select a Root to explore its Verbs</div>
            </div>
            <input type="text" id="search-box" placeholder="Search roots or verbs...">
        </div>

        <div id="controls-panel">
            <div class="control-group">
                <span class="control-label">Tense</span>
                <select id="tense-select">
                    <option value="inf">Infinitive (执驻职注止)</option>
                    <option value="past">Past (注指址专)</option>
                    <option value="present">Present (止侄)</option>
                    <option value="future">Future (注指转执)</option>
                    <option value="imperative">Imperative (爪执旨旨)</option>
                </select>
            </div>
            <div class="control-group">
                <span class="control-label">Pronoun</span>
                <select id="pronoun-select" disabled>
                    <option value="any">--</option>
                    <option value="">I (植执)</option>
                    <option value="转">You m.s. (址转指旨)</option>
                    <option value="转">You f.s. (址转职旨)</option>
                    <option value="">He (旨)</option>
                    <option value="">She (执)</option>
                    <option value="">We (植址职旨)</option>
                    <option value="转">You m.pl. (址转侄旨)</option>
                    <option value="转">You f.pl. (址转侄旨)</option>
                    <option value="">They m. (值)</option>
                    <option value="">They f. (值)</option>
                </select>
            </div>
        </div>

        <div id="info-panel">
            <button id="close-panel">&times;</button>
            <div id="panel-content"></div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import TWEEN from 'three/addons/libs/tween.module.js';

        // --- State ---
        const state = {
            tense: 'inf',
            pronoun: '', // Default to 'I' for conjugations
            activeRoot: null,
            roots: {}, // Grouped data
            objects: {
                roots: [],
                satellites: []
            }
        };

        // --- Constants ---
        const HELIX_RADIUS = 30;
        const HELIX_HEIGHT_STEP = 8;
        const SATELLITE_RADIUS = 35; // Increased from 25
        const FOCUS_GAP = 80; // Vertical gap to create around active root

        // --- Three.js Globals ---
        let scene, camera, renderer, labelRenderer, controls, raycaster, mouse;
        let rootGroup, satelliteGroup;

        init();

        async function init() {
            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.008);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 80);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.zIndex = '0';
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.zIndex = '1'; // Ensure it's above WebGL but below UI
            labelRenderer.domElement.style.pointerEvents = 'none'; // Allow clicks to pass through to WebGL
            document.getElementById('canvas-container').appendChild(labelRenderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 800; // Increased to allow seeing more of the helix
            controls.zoomSpeed = 2.0;   // Faster zooming
            controls.enablePan = true;
            controls.screenSpacePanning = true; // Pan moves in screen space (Up/Down moves list Up/Down)
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.PAN,
                RIGHT: THREE.MOUSE.PAN
            };

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Groups
            rootGroup = new THREE.Group();
            satelliteGroup = new THREE.Group();
            scene.add(rootGroup);
            scene.add(satelliteGroup);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0x4db8ff, 1, 100);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
            document.getElementById('close-panel').addEventListener('click', () => {
                document.getElementById('info-panel').classList.remove('visible');
            });

            // Search Listener
            const searchBox = document.getElementById('search-box');
            searchBox.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    performSearch(searchBox.value);
                }
            });

            // 2. Load & Process Data
            try {
                const response = await fetch('verbs.json');
                const rawData = await response.json();
                processData(rawData);
                buildHelix();
                setupUI();
                animate();
            } catch (e) {
                console.error("Failed to load data", e);
            }

            window.addEventListener('resize', onWindowResize);
        }

        function processData(data) {
            // Group by Root
            for (const key in data) {
                const verb = data[key];
                const rootStr = verb.rt.join('.');
                if (!state.roots[rootStr]) {
                    state.roots[rootStr] = [];
                }
                // Add key to verb object for reference
                verb._key = key;
                state.roots[rootStr].push(verb);
            }
        }

        function getViridisColor(t) {
            t = Math.max(0, Math.min(1, t));
            const stops = [
                { t: 0.0, c: [68, 1, 84] },     // #440154
                { t: 0.25, c: [59, 82, 139] },  // #3b528b
                { t: 0.5, c: [33, 145, 140] },  // #21918c
                { t: 0.75, c: [94, 201, 98] },  // #5ec962
                { t: 1.0, c: [253, 231, 37] }   // #fde725
            ];
            
            for (let i = 0; i < stops.length - 1; i++) {
                if (t >= stops[i].t && t <= stops[i+1].t) {
                    const t0 = stops[i].t;
                    const t1 = stops[i+1].t;
                    const f = (t - t0) / (t1 - t0);
                    const c0 = stops[i].c;
                    const c1 = stops[i+1].c;
                    const r = c0[0] + (c1[0] - c0[0]) * f;
                    const g = c0[1] + (c1[1] - c0[1]) * f;
                    const b = c0[2] + (c1[2] - c0[2]) * f;
                    return new THREE.Color(r/255, g/255, b/255);
                }
            }
            return new THREE.Color(stops[stops.length-1].c[0]/255, stops[stops.length-1].c[1]/255, stops[stops.length-1].c[2]/255);
        }

        function buildHelix() {
            const roots = Object.keys(state.roots).sort(); // Alphabetical sort
            const totalRoots = roots.length;
            
            roots.forEach((rootStr, index) => {
                const angle = index * 0.5; // Spiral angle step
                const y = (index - totalRoots / 2) * HELIX_HEIGHT_STEP;
                const x = Math.cos(angle) * HELIX_RADIUS;
                const z = Math.sin(angle) * HELIX_RADIUS;

                // Gradient Color (Viridis)
                let val = index / totalRoots;
                let color = getViridisColor(val);

                // 3D Object (Glowing Sphere)
                const geometry = new THREE.SphereGeometry(0.8, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                
                // Store data in mesh
                mesh.userData = { type: 'root', root: rootStr, baseIndex: index, color: color };
                rootGroup.add(mesh);

                // Label
                const div = document.createElement('div');
                div.className = 'root-label';
                div.textContent = rootStr;
                div.style.setProperty('--root-color', '#' + color.getHexString());
                div.onclick = () => selectRoot(rootStr, mesh.position);
                
                const label = new CSS2DObject(div);
                label.position.set(0, 1, 0);
                mesh.add(label);

                state.objects.roots.push({ mesh, label, root: rootStr });
            });
        }

        function updateHelixInfinite() {
            if (state.objects.roots.length === 0) return;

            const totalRoots = state.objects.roots.length;
            const totalHeight = totalRoots * HELIX_HEIGHT_STEP;
            const halfHeight = totalHeight / 2;
            const centerY = controls.target.y; // Center wrapping around look target

            // Find active root index if any
            let activeIndex = -1;
            if (state.activeRoot) {
                const activeObj = state.objects.roots.find(o => o.root === state.activeRoot);
                if (activeObj) activeIndex = activeObj.mesh.userData.baseIndex;
            }

            state.objects.roots.forEach(obj => {
                // 1. Calculate Base Position (Infinite Scroll)
                let y = obj.mesh.position.y;
                const originalY = (obj.mesh.userData.baseIndex - totalRoots / 2) * HELIX_HEIGHT_STEP;
                
                // The ideal Y is originalY + k * totalHeight
                const k = Math.round((centerY - originalY) / totalHeight);
                let newY = originalY + k * totalHeight;

                // 2. Apply Focus Distortion (Gap)
                // We want to push items away from the active root to make space
                if (activeIndex !== -1) {
                    // We need to know the "virtual index" of this item relative to the active one
                    // taking wrapping into account.
                    // The active item is at activeIndex.
                    // This item is at obj.mesh.userData.baseIndex.
                    // But they might be wrapped.
                    
                    // Let's use Y distance to determine relative position
                    const activeObj = state.objects.roots.find(o => o.root === state.activeRoot);
                    // We can't rely on activeObj.mesh.position.y because it's being animated/updated
                    // Instead, calculate the "undistorted" Y of the active object closest to centerY
                    const activeOriginalY = (activeIndex - totalRoots / 2) * HELIX_HEIGHT_STEP;
                    const activeK = Math.round((centerY - activeOriginalY) / totalHeight);
                    const activeY = activeOriginalY + activeK * totalHeight;

                    const distY = newY - activeY;
                    
                    // Apply gap
                    if (Math.abs(distY) < 0.1) {
                        // This is the active root, no offset
                    } else if (distY > 0) {
                        newY += FOCUS_GAP / 2;
                    } else {
                        newY -= FOCUS_GAP / 2;
                    }
                }

                // Smoothly interpolate to newY? 
                // For infinite scroll, we usually snap. But for focus gap, we want smooth.
                // However, updateHelixInfinite runs every frame. If we just set it, it snaps.
                // We can use a simple lerp factor.
                
                const diff = newY - obj.mesh.position.y;
                if (Math.abs(diff) > 0.1) {
                    // If the difference is huge (wrapping), snap.
                    if (Math.abs(diff) > totalHeight / 2) {
                        obj.mesh.position.y = newY;
                    } else {
                        // Lerp for smooth gap opening
                        obj.mesh.position.y += diff * 0.1;
                    }
                    
                    // Update X/Z to maintain spiral
                    // The angle depends on the continuous index
                    // continuousIndex = newY / HELIX_HEIGHT_STEP + totalRoots/2
                    // Note: We use the *undistorted* Y for X/Z to keep the spiral shape consistent?
                    // Or do we want the spiral to stretch? 
                    // If we stretch X/Z, it looks like the spring is being pulled apart. That's good.
                    const continuousIndex = obj.mesh.position.y / HELIX_HEIGHT_STEP + totalRoots / 2;
                    const angle = continuousIndex * 0.5;
                    
                    obj.mesh.position.x = Math.cos(angle) * HELIX_RADIUS;
                    obj.mesh.position.z = Math.sin(angle) * HELIX_RADIUS;
                }
            });
        }

        function selectRoot(rootStr, position) {
            if (state.activeRoot === rootStr) return;
            state.activeRoot = rootStr;

            // Highlight Label
            state.objects.roots.forEach(obj => {
                if (obj.root === rootStr) obj.label.element.classList.add('active');
                else obj.label.element.classList.remove('active');
            });

            // Move Camera to focus (smooth tween)
            const targetPos = position.clone();
            const camOffset = new THREE.Vector3(0, 0, 150); // Distance from root (increased from 100)
            const endCamPos = targetPos.clone().add(camOffset);

            new TWEEN.Tween(camera.position)
                .to(endCamPos, 1000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
            
            new TWEEN.Tween(controls.target)
                .to(targetPos, 1000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();

            // Expand Satellites
            const rootObj = state.objects.roots.find(o => o.root === rootStr);
            const rootColor = rootObj ? rootObj.mesh.userData.color : new THREE.Color(0x4db8ff);
            // Pass the mesh itself so satellites can be parented
            spawnSatellites(rootStr, rootObj.mesh, rootColor);
        }

        function spawnSatellites(rootStr, rootMesh, rootColor) {
            // Clear existing satellites
            // Note: We need to remove them from their parents (which are root meshes)
            // But state.objects.satellites stores { labelObj, verb }.
            // labelObj is a CSS2DObject.
            // We also added a Line to satelliteGroup? No, we should add Line to rootMesh too.
            
            // Clean up previous satellites
            state.objects.satellites.forEach(obj => {
                if (obj.line) obj.line.removeFromParent();
                if (obj.labelObj) obj.labelObj.removeFromParent();
            });
            state.objects.satellites = [];

            const verbs = state.roots[rootStr];
            const count = verbs.length;

            // Helical arrangement parameters
            const turns = 2; 
            const heightSpread = 40; // Increased from 20 to use the gap
            
            verbs.forEach((verb, i) => {
                // Helical path around the root (Local Coordinates)
                const progress = i / count;
                const angle = progress * Math.PI * 2 * turns;
                const yOffset = (progress - 0.5) * heightSpread;
                
                const x = Math.cos(angle) * SATELLITE_RADIUS;
                const y = yOffset;
                const z = Math.sin(angle) * SATELLITE_RADIUS;

                const pos = new THREE.Vector3(x, y, z);

                // Line to center (0,0,0 is root center in local space)
                const points = [new THREE.Vector3(0,0,0), pos];
                const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                const lineMat = new THREE.LineBasicMaterial({ 
                    color: rootColor, 
                    transparent: true, 
                    opacity: 0.4 
                });
                const line = new THREE.Line(lineGeo, lineMat);
                rootMesh.add(line);

                // Verb Node
                const div = document.createElement('div');
                div.className = 'verb-label';
                div.style.borderColor = '#' + rootColor.getHexString();
                div.style.boxShadow = `0 0 10px #${rootColor.getHexString()}`;
                
                // Click on container does nothing (buttons handle actions)
                div.onclick = (e) => e.stopPropagation();
                
                const labelObj = new CSS2DObject(div);
                labelObj.position.copy(pos);
                rootMesh.add(labelObj);

                state.objects.satellites.push({ labelObj, line, verb });
            });

            updateSatelliteLabels();
        }

        function updateSatelliteLabels() {
            state.objects.satellites.forEach(obj => {
                const verb = obj.verb;
                const div = obj.labelObj.element;
                
                let text = '';
                let sub = verb.bnE; // Binyan as subtitle
                let audioPath = null;

                if (state.tense === 'inf') {
                    text = verb.inf;
                    // Find audio for infinitive
                    if (verb.conjugations && verb.conjugations.inf && verb.conjugations.inf[0]) {
                        audioPath = verb.conjugations.inf[0].aud;
                    }
                } else {
                    // Look up conjugation
                    const forms = verb.conjugations ? verb.conjugations[state.tense] : null;
                    if (forms) {
                        // Find form matching current pronoun
                        // Note: Imperative doesn't have all pronouns, Future/Past do.
                        // We need to map UI pronoun to Data pronoun.
                        const match = forms.find(f => f.prn === state.pronoun);
                        if (match) {
                            text = match.frm; // The Hebrew word
                            sub = match.trl;  // Transliteration
                            audioPath = match.aud;
                        } else {
                            text = '-';
                            sub = 'N/A';
                        }
                    } else {
                        text = '-';
                        sub = 'No Data';
                    }
                }

                div.innerHTML = `
                    <div style="font-size: 1.2em; font-weight: bold;">${text}</div>
                    <div class="verb-sub">${sub}</div>
                    <div class="verb-actions">
                        ${audioPath ? `<button class="verb-btn play-btn" title="Play Audio"></button>` : ''}
                        <button class="verb-btn info-btn" title="Show Info">癸</button>
                    </div>
                `;
                
                // Attach listeners
                const playBtn = div.querySelector('.play-btn');
                if (playBtn) {
                    playBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (audioPath) playAudio(audioPath);
                    };
                }

                const infoBtn = div.querySelector('.info-btn');
                if (infoBtn) {
                    infoBtn.onclick = (e) => {
                        e.stopPropagation();
                        showVerbInfo(verb);
                    };
                }
            });
        }

        function showVerbInfo(verb) {
            const panel = document.getElementById('info-panel');
            const content = document.getElementById('panel-content');
            
            let html = `
                <h2>${verb.inf}</h2>
                <p style="color: #aaa;">${verb.mng.join(', ')}</p>
                <hr style="border-color: #333;">
                <div style="margin-bottom: 10px;">
                    <strong>Root:</strong> ${verb.rt.join('.')}<br>
                    <strong>Binyan:</strong> ${verb.bn} (${verb.bnE})
                </div>
            `;

            // Examples
            if (verb.examples && verb.examples.length > 0) {
                html += `<h3>Examples</h3>`;
                verb.examples.forEach(ex => {
                    let exAudio = ex.audio ? '../../' + ex.audio : null;
                    html += `
                        <div style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                            <div style="display:flex; justify-content:space-between;">
                                <span style="font-size: 1.1em; direction: rtl;">${ex.hebrew}</span>
                                ${exAudio ? `<button onclick="playAudio('${exAudio}')" style="background:none; border:none; cursor:pointer;"></button>` : ''}
                            </div>
                            ${ex.transliteration ? `<div style="color: #888; font-size: 0.9em;">${ex.transliteration}</div>` : ''}
                            <div style="font-style: italic;">${ex.translation}</div>
                        </div>
                    `;
                });
            }

            content.innerHTML = html;
            panel.classList.add('visible');
        }

        window.playAudio = function(path) {
            // Fix path if needed
            if (path.startsWith('audio/')) path = '../../' + path.replace('.wav', '.mp4');
            
            const audio = new Audio(path);
            audio.play().catch(e => console.warn("Audio play failed", e));
        }

        function setupUI() {
            const tenseSelect = document.getElementById('tense-select');
            const pronounSelect = document.getElementById('pronoun-select');

            tenseSelect.addEventListener('change', (e) => {
                state.tense = e.target.value;
                // Enable/Disable pronoun select based on tense
                if (state.tense === 'inf') {
                    pronounSelect.disabled = true;
                } else {
                    pronounSelect.disabled = false;
                }
                updateSatelliteLabels();
            });

            pronounSelect.addEventListener('change', (e) => {
                state.pronoun = e.target.value;
                updateSatelliteLabels();
            });
        }

        function performSearch(query) {
            if (!query) return;
            const q = query.toLowerCase().trim();
            
            // 1. Search Roots
            // Try exact match first, then partial
            let rootMatch = Object.keys(state.roots).find(r => r.toLowerCase() === q || r.replace(/\./g, '').toLowerCase() === q);
            if (!rootMatch) {
                rootMatch = Object.keys(state.roots).find(r => r.toLowerCase().includes(q) || r.replace(/\./g, '').toLowerCase().includes(q));
            }

            if (rootMatch) {
                const obj = state.objects.roots.find(o => o.root === rootMatch);
                if (obj) {
                    selectRoot(rootMatch, obj.mesh.position);
                    return;
                }
            }

            // 2. Search Verbs (Infinitive or Meaning)
            for (const root in state.roots) {
                const verbs = state.roots[root];
                const verbMatch = verbs.find(v => 
                    v.inf.includes(q) || 
                    (v.mng && v.mng.some(m => m.toLowerCase().includes(q)))
                );
                
                if (verbMatch) {
                    const obj = state.objects.roots.find(o => o.root === root);
                    if (obj) {
                        selectRoot(root, obj.mesh.position);
                        // Ideally we would highlight the specific verb satellite too, 
                        // but selectRoot respawns them. 
                        // We could pass a target verb to selectRoot?
                        // For now, just going to the root is a huge improvement.
                        return;
                    }
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            updateHelixInfinite();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        function onPointerDown(event) {
            // Only handle clicks on the canvas/renderer, not UI
            if (event.target.closest('#ui-layer')) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check intersections with Root Spheres
            const intersects = raycaster.intersectObjects(rootGroup.children);

            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.type === 'root') {
                    selectRoot(object.userData.root, object.position);
                }
            }
        }
    </script>
</body>
</html>
