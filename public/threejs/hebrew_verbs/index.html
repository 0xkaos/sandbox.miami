<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hebrew Verbs Galaxy - Roots Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
            z-index: 1000;
        }

        /* Top Bar */
        #top-bar {
            padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: auto;
        }

        /* Controls Panel */
        #controls-panel {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid #444;
            border-radius: 15px;
            padding: 15px 25px;
            display: flex; gap: 20px;
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(77, 184, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .control-group { display: flex; flex-direction: column; gap: 5px; }
        .control-label { font-size: 0.8em; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        
        select {
            background: #111; color: #fff; border: 1px solid #444;
            padding: 8px 12px; border-radius: 5px; font-size: 1em;
            outline: none; cursor: pointer; min-width: 120px;
        }
        select:hover { border-color: #4db8ff; }

        /* 3D Labels */
        .root-label {
            font-size: 24px; font-weight: bold; color: #4db8ff;
            text-shadow: 0 0 10px rgba(77, 184, 255, 0.5);
            cursor: pointer; pointer-events: auto;
            transition: all 0.3s;
            user-select: none;
        }
        .root-label:hover { color: #fff; transform: scale(1.2); }
        .root-label.active { color: #fff; text-shadow: 0 0 20px #4db8ff; font-size: 32px; }

        .verb-label {
            font-size: 16px; color: #aaa;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px; border-radius: 5px;
            border: 1px solid #333;
            cursor: pointer; pointer-events: auto;
            transition: all 0.2s;
            white-space: nowrap;
            text-align: center;
        }
        .verb-label:hover { 
            background: rgba(77, 184, 255, 0.2); 
            border-color: #4db8ff; color: white;
        }
        .verb-sub { font-size: 0.8em; color: #888; display: block; margin-top: 2px; }

        /* Info Panel (Right Side) */
        #info-panel {
            position: absolute; top: 80px; right: 20px; bottom: 100px;
            width: 350px;
            background: rgba(10, 10, 15, 0.95);
            border-left: 1px solid #333;
            padding: 20px;
            transform: translateX(110%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            overflow-y: auto;
            border-radius: 10px;
        }
        #info-panel.visible { transform: translateX(0); }

        h1 { margin: 0; font-size: 1.5em; background: linear-gradient(45deg, #4db8ff, #b84dff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        /* Search */
        #search-box {
            background: rgba(0,0,0,0.5); border: 1px solid #444; color: white;
            padding: 8px; border-radius: 5px; width: 200px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="top-bar">
            <div>
                <h1> Hebrew Roots Helix</h1>
                <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">Select a Root to explore its Verbs</div>
            </div>
            <input type="text" id="search-box" placeholder="Search roots or verbs...">
        </div>

        <div id="controls-panel">
            <div class="control-group">
                <span class="control-label">Tense</span>
                <select id="tense-select">
                    <option value="inf">Infinitive (执驻职注止)</option>
                    <option value="past">Past (注指址专)</option>
                    <option value="present">Present (止侄)</option>
                    <option value="future">Future (注指转执)</option>
                    <option value="imperative">Imperative (爪执旨旨)</option>
                </select>
            </div>
            <div class="control-group">
                <span class="control-label">Pronoun</span>
                <select id="pronoun-select" disabled>
                    <option value="any">--</option>
                    <option value="">I (植执)</option>
                    <option value="转">You m.s. (址转指旨)</option>
                    <option value="转">You f.s. (址转职旨)</option>
                    <option value="">He (旨)</option>
                    <option value="">She (执)</option>
                    <option value="">We (植址职旨)</option>
                    <option value="转">You m.pl. (址转侄旨)</option>
                    <option value="转">You f.pl. (址转侄旨)</option>
                    <option value="">They m. (值)</option>
                    <option value="">They f. (值)</option>
                </select>
            </div>
        </div>

        <div id="info-panel">
            <div id="panel-content"></div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import TWEEN from 'three/addons/libs/tween.module.js';

        // --- State ---
        const state = {
            tense: 'inf',
            pronoun: '', // Default to 'I' for conjugations
            activeRoot: null,
            roots: {}, // Grouped data
            objects: {
                roots: [],
                satellites: []
            }
        };

        // --- Constants ---
        const HELIX_RADIUS = 30;
        const HELIX_HEIGHT_STEP = 8;
        const SATELLITE_RADIUS = 15;

        // --- Three.js Globals ---
        let scene, camera, renderer, labelRenderer, controls, raycaster, mouse;
        let rootGroup, satelliteGroup;

        init();

        async function init() {
            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.008);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 80);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.zIndex = '0';
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.zIndex = '1'; // Ensure it's above WebGL but below UI
            document.getElementById('canvas-container').appendChild(labelRenderer.domElement);

            controls = new OrbitControls(camera, labelRenderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 200;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Groups
            rootGroup = new THREE.Group();
            satelliteGroup = new THREE.Group();
            scene.add(rootGroup);
            scene.add(satelliteGroup);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0x4db8ff, 1, 100);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);

            // 2. Load & Process Data
            try {
                const response = await fetch('verbs.json');
                const rawData = await response.json();
                processData(rawData);
                buildHelix();
                setupUI();
                animate();
            } catch (e) {
                console.error("Failed to load data", e);
            }

            window.addEventListener('resize', onWindowResize);
        }

        function processData(data) {
            // Group by Root
            for (const key in data) {
                const verb = data[key];
                const rootStr = verb.rt.join('.');
                if (!state.roots[rootStr]) {
                    state.roots[rootStr] = [];
                }
                // Add key to verb object for reference
                verb._key = key;
                state.roots[rootStr].push(verb);
            }
        }

        function buildHelix() {
            const roots = Object.keys(state.roots).sort(); // Alphabetical sort
            
            roots.forEach((rootStr, index) => {
                const angle = index * 0.5; // Spiral angle step
                const y = (index - roots.length / 2) * HELIX_HEIGHT_STEP;
                const x = Math.cos(angle) * HELIX_RADIUS;
                const z = Math.sin(angle) * HELIX_RADIUS;

                // 3D Object (Glowing Sphere)
                const geometry = new THREE.SphereGeometry(0.5, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: 0x4db8ff });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                
                // Store data in mesh
                mesh.userData = { type: 'root', root: rootStr };
                rootGroup.add(mesh);

                // Label
                const div = document.createElement('div');
                div.className = 'root-label';
                div.textContent = rootStr;
                div.onclick = () => selectRoot(rootStr, mesh.position);
                
                const label = new CSS2DObject(div);
                label.position.set(0, 1, 0);
                mesh.add(label);

                state.objects.roots.push({ mesh, label, root: rootStr });
            });
        }

        function selectRoot(rootStr, position) {
            if (state.activeRoot === rootStr) return;
            state.activeRoot = rootStr;

            // Highlight Label
            state.objects.roots.forEach(obj => {
                if (obj.root === rootStr) obj.label.element.classList.add('active');
                else obj.label.element.classList.remove('active');
            });

            // Move Camera to focus (smooth tween)
            const targetPos = position.clone();
            const camOffset = new THREE.Vector3(0, 0, 40); // Distance from root
            const endCamPos = targetPos.clone().add(camOffset);

            new TWEEN.Tween(camera.position)
                .to(endCamPos, 1000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
            
            new TWEEN.Tween(controls.target)
                .to(targetPos, 1000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();

            // Expand Satellites
            spawnSatellites(rootStr, position);
        }

        function spawnSatellites(rootStr, centerPos) {
            // Clear existing satellites
            while(satelliteGroup.children.length > 0){ 
                satelliteGroup.remove(satelliteGroup.children[0]); 
            }
            state.objects.satellites = [];

            const verbs = state.roots[rootStr];
            const count = verbs.length;

            verbs.forEach((verb, i) => {
                // Arrange in a circle around the root
                const angle = (i / count) * Math.PI * 2;
                const x = centerPos.x + Math.cos(angle) * SATELLITE_RADIUS;
                const y = centerPos.y + Math.sin(angle) * SATELLITE_RADIUS;
                const z = centerPos.z; // Flat disc relative to camera usually better, but let's try 3D

                // Line to center
                const points = [centerPos, new THREE.Vector3(x, y, z)];
                const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                const lineMat = new THREE.LineBasicMaterial({ color: 0x4db8ff, transparent: true, opacity: 0.3 });
                const line = new THREE.Line(lineGeo, lineMat);
                satelliteGroup.add(line);

                // Verb Node
                const div = document.createElement('div');
                div.className = 'verb-label';
                div.onclick = () => showVerbInfo(verb);
                
                const labelObj = new CSS2DObject(div);
                labelObj.position.set(x, y, z);
                satelliteGroup.add(labelObj);

                state.objects.satellites.push({ labelObj, verb });
            });

            updateSatelliteLabels();
        }

        function updateSatelliteLabels() {
            state.objects.satellites.forEach(obj => {
                const verb = obj.verb;
                const div = obj.labelObj.element;
                
                let text = '';
                let sub = verb.bnE; // Binyan as subtitle
                let audioPath = null;

                if (state.tense === 'inf') {
                    text = verb.inf;
                    // Find audio for infinitive
                    if (verb.conjugations && verb.conjugations.inf && verb.conjugations.inf[0]) {
                        audioPath = verb.conjugations.inf[0].aud;
                    }
                } else {
                    // Look up conjugation
                    const forms = verb.conjugations ? verb.conjugations[state.tense] : null;
                    if (forms) {
                        // Find form matching current pronoun
                        // Note: Imperative doesn't have all pronouns, Future/Past do.
                        // We need to map UI pronoun to Data pronoun.
                        const match = forms.find(f => f.prn === state.pronoun);
                        if (match) {
                            text = match.frm; // The Hebrew word
                            sub = match.trl;  // Transliteration
                            audioPath = match.aud;
                        } else {
                            text = '-';
                            sub = 'N/A';
                        }
                    } else {
                        text = '-';
                        sub = 'No Data';
                    }
                }

                div.innerHTML = `
                    <div style="font-size: 1.2em; font-weight: bold;">${text}</div>
                    <div class="verb-sub">${sub}</div>
                `;
                
                // Attach audio player to the div click (override showInfo for a moment? No, let's play on hover or add a button? 
                // The user said "persistent when opening another node".
                // Let's make clicking the node play audio AND show info.
                div.onclick = (e) => {
                    e.stopPropagation();
                    if (audioPath) playAudio(audioPath);
                    showVerbInfo(verb);
                };
            });
        }

        function showVerbInfo(verb) {
            const panel = document.getElementById('info-panel');
            const content = document.getElementById('panel-content');
            
            let html = `
                <h2>${verb.inf}</h2>
                <p style="color: #aaa;">${verb.mng.join(', ')}</p>
                <hr style="border-color: #333;">
                <div style="margin-bottom: 10px;">
                    <strong>Root:</strong> ${verb.rt.join('.')}<br>
                    <strong>Binyan:</strong> ${verb.bn} (${verb.bnE})
                </div>
            `;

            // Examples
            if (verb.examples && verb.examples.length > 0) {
                html += `<h3>Examples</h3>`;
                verb.examples.forEach(ex => {
                    let exAudio = ex.audio ? '../../' + ex.audio : null;
                    html += `
                        <div style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                            <div style="display:flex; justify-content:space-between;">
                                <span style="font-size: 1.1em; direction: rtl;">${ex.hebrew}</span>
                                ${exAudio ? `<button onclick="playAudio('${exAudio}')" style="background:none; border:none; cursor:pointer;"></button>` : ''}
                            </div>
                            <div style="color: #888; font-size: 0.9em;">${ex.transliteration}</div>
                            <div style="font-style: italic;">${ex.translation}</div>
                        </div>
                    `;
                });
            }

            content.innerHTML = html;
            panel.classList.add('visible');
        }

        window.playAudio = function(path) {
            // Fix path if needed
            if (path.startsWith('audio/')) path = '../../' + path.replace('.wav', '.mp4');
            
            const audio = new Audio(path);
            audio.play().catch(e => console.warn("Audio play failed", e));
        }

        function setupUI() {
            const tenseSelect = document.getElementById('tense-select');
            const pronounSelect = document.getElementById('pronoun-select');

            tenseSelect.addEventListener('change', (e) => {
                state.tense = e.target.value;
                // Enable/Disable pronoun select based on tense
                if (state.tense === 'inf') {
                    pronounSelect.disabled = true;
                } else {
                    pronounSelect.disabled = false;
                }
                updateSatelliteLabels();
            });

            pronounSelect.addEventListener('change', (e) => {
                state.pronoun = e.target.value;
                updateSatelliteLabels();
            });

            // Search
            document.getElementById('search-box').addEventListener('input', (e) => {
                const q = e.target.value.toLowerCase();
                // Simple root search
                const rootMatch = Object.keys(state.roots).find(r => r.includes(q) || r.replace(/\./g, '').includes(q));
                if (rootMatch) {
                    const mesh = state.objects.roots.find(o => o.root === rootMatch).mesh;
                    selectRoot(rootMatch, mesh.position);
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        function onPointerDown(event) {
            // Only handle clicks on the canvas/renderer, not UI
            if (event.target.closest('#ui-layer')) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check intersections with Root Spheres
            const intersects = raycaster.intersectObjects(rootGroup.children);

            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.type === 'root') {
                    selectRoot(object.userData.root, object.position);
                }
            }
        }
    </script>
</body>
</html>
