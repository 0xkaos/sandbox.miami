<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaotic Attractor Viewer V2</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #ccc; font-family: monospace; }
        #ui-container { position: absolute; top: 10px; right: 10px; }
        #status { position: absolute; bottom: 10px; left: 10px; pointer-events: none; text-shadow: 0 0 2px #000; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none;
            justify-content: center; align-items: center; flex-direction: column;
            z-index: 100;
        }
        #progress-bar {
            width: 300px; height: 20px; background: #333; border: 1px solid #555; margin-top: 10px;
        }
        #progress-fill {
            width: 0%; height: 100%; background: #00ffff; transition: width 0.1s;
        }
    </style>
</head>
<body>
    <div id="status">Initializing...</div>
    <div id="overlay">
        <div id="export-status">Rendering Video...</div>
        <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>

    <script src="https://unpkg.com/ccapture.js@1.1.0/build/CCapture.all.min.js"></script>
    <script src="/vendor/ffmpeg/ffmpeg.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js",
            "mp4-muxer": "https://cdn.jsdelivr.net/npm/mp4-muxer@5.1.0/build/mp4-muxer.mjs"
        }
    }
    </script>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { GPUComputationRenderer } from "three/addons/misc/GPUComputationRenderer.js";
        import GUI from "lil-gui";
        import * as Mp4Muxer from "mp4-muxer";

        // --- Configuration & State ---
        const CONFIG = {
            attractor: 'thomas',
            particleCount: 1024, // Texture size (1024x1024 = 1M)
            opacity: 0.1,
            pointSize: 0.05,
            color: "#00ffff",
            speed: 1.0,
            
            // Camera
            rotationSpeed: 0.2,
            autoRotate: true,

            // Export
            exportWidth: 1080,
            exportHeight: 1920,
            exportFps: 60,
            exportDuration: 10,
            exportBitrate: 20, // Mbps
        };

        // --- Shaders ---
        const SHADERS = {
            thomas: `
                uniform float b;
                uniform float dt;
                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 pos = texture2D(texturePosition, uv);
                    float dx = sin(pos.y) - b * pos.x;
                    float dy = sin(pos.z) - b * pos.y;
                    float dz = sin(pos.x) - b * pos.z;
                    vec3 next = pos.xyz + vec3(dx, dy, dz) * dt;
                    gl_FragColor = vec4(next, 1.0);
                }
            `,
            aizawa: `
                uniform float a;
                uniform float b;
                uniform float c;
                uniform float d;
                uniform float e;
                uniform float f;
                uniform float dt;
                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 pos = texture2D(texturePosition, uv);
                    float x = pos.x; float y = pos.y; float z = pos.z;
                    float dx = (z - b) * x - d * y;
                    float dy = d * x + (z - b) * y;
                    float dz = c + a * z - (z * z * z / 3.0) - (x * x + y * y) * (1.0 + e * z) + f * z * x * x * x;
                    vec3 next = pos.xyz + vec3(dx, dy, dz) * dt;
                    gl_FragColor = vec4(next, 1.0);
                }
            `,
            lorenz: `
                uniform float sigma;
                uniform float rho;
                uniform float beta;
                uniform float dt;
                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 pos = texture2D(texturePosition, uv);
                    float x = pos.x; float y = pos.y; float z = pos.z;
                    float dx = sigma * (y - x);
                    float dy = x * (rho - z) - y;
                    float dz = x * y - beta * z;
                    vec3 next = pos.xyz + vec3(dx, dy, dz) * dt;
                    gl_FragColor = vec4(next, 1.0);
                }
            `
        };

        const ATTRACTORS = {
            thomas: {
                defaults: { b: 0.208186 },
                ranges: { b: [0, 1] },
                shader: SHADERS.thomas,
                scale: 0.5,
                dt: 0.1
            },
            aizawa: {
                defaults: { a: 0.95, b: 0.7, c: 0.6, d: 3.5, e: 0.25, f: 0.1 },
                ranges: { a: [0, 1], b: [0, 1], c: [0, 1], d: [0, 5], e: [0, 1], f: [0, 1] },
                shader: SHADERS.aizawa,
                scale: 2.0,
                dt: 0.01
            },
            lorenz: {
                defaults: { sigma: 10.0, rho: 28.0, beta: 2.6666 },
                ranges: { sigma: [0, 50], rho: [0, 100], beta: [0, 10] },
                shader: SHADERS.lorenz,
                scale: 1.0,
                dt: 0.005
            }
        };

        // --- Globals ---
        let scene, camera, renderer, controls;
        let gpuCompute, positionVariable;
        let points, material;
        let gui;
        let attractorParams = {};
        let isExporting = false;

        // --- Initialization ---
        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false }); // Antialias off for particles usually better perf
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // GUI
            gui = new GUI({ title: "Attractor Settings" });
            setupGui();

            // Initial Setup
            changeAttractor(CONFIG.attractor);

            // Events
            window.addEventListener('resize', onWindowResize);
            
            // Start Loop
            animate();
            
            document.getElementById('status').innerText = "Ready.";
        }

        function setupGui() {
            const mainFolder = gui.addFolder("General");
            mainFolder.add(CONFIG, 'attractor', Object.keys(ATTRACTORS)).onChange(changeAttractor);
            mainFolder.addColor(CONFIG, 'color').onChange(v => { if(material) material.color.set(v); });
            mainFolder.add(CONFIG, 'opacity', 0.01, 1.0).onChange(v => { if(material) material.opacity = v; });
            mainFolder.add(CONFIG, 'pointSize', 0.01, 0.5).onChange(v => { if(material) material.size = v; });
            mainFolder.add(CONFIG, 'speed', 0, 5);
            mainFolder.add(CONFIG, 'autoRotate');
            mainFolder.add(CONFIG, 'rotationSpeed', 0, 2);

            const exportFolder = gui.addFolder("Export Video");
            exportFolder.add(CONFIG, 'exportWidth', [720, 1080, 1920, 2160, 3840]);
            exportFolder.add(CONFIG, 'exportHeight', [720, 1080, 1920, 2160, 3840]);
            exportFolder.add(CONFIG, 'exportFps', [30, 60]);
            exportFolder.add(CONFIG, 'exportDuration', 1, 60).name("Duration (s)");
            exportFolder.add(CONFIG, 'exportBitrate', 1, 100).name("Bitrate (Mbps)");
            exportFolder.add({ export: startExport }, 'export').name("START EXPORT");
        }

        function changeAttractor(name) {
            const def = ATTRACTORS[name];
            if (!def) return;

            // Cleanup old GPGPU
            if (gpuCompute) {
                // Dispose logic if needed
            }

            // Init GPGPU
            const size = CONFIG.particleCount;
            gpuCompute = new GPUComputationRenderer(size, size, renderer);

            const dtPosition = gpuCompute.createTexture();
            fillTexture(dtPosition, name);

            positionVariable = gpuCompute.addVariable("texturePosition", def.shader, dtPosition);
            gpuCompute.setVariableDependencies(positionVariable, [positionVariable]);

            // Uniforms
            attractorParams = { ...def.defaults };
            const uniforms = positionVariable.material.uniforms;
            uniforms["dt"] = { value: def.dt * CONFIG.speed };
            
            // Add params to GUI
            // Remove old param folder if exists
            if (gui.folders_params) gui.folders_params.destroy();
            gui.folders_params = gui.addFolder(name + " Parameters");
            
            for (const key in def.defaults) {
                uniforms[key] = { value: def.defaults[key] };
                gui.folders_params.add(attractorParams, key, def.ranges[key][0], def.ranges[key][1]).onChange(v => {
                    uniforms[key].value = v;
                });
            }

            const error = gpuCompute.init();
            if (error !== null) {
                console.error(error);
            }

            // Create Particles
            if (points) scene.remove(points);
            
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(size * size * 3);
            const uvs = new Float32Array(size * size * 2);
            
            for (let i = 0; i < size * size; i++) {
                positions[i * 3] = 0;
                positions[i * 3 + 1] = 0;
                positions[i * 3 + 2] = 0;
                
                const x = (i % size) / size;
                const y = Math.floor(i / size) / size;
                uvs[i * 2] = x;
                uvs[i * 2 + 1] = y;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

            // Material
            // We need a custom shader material to read from the GPGPU texture
            const uniformsMat = {
                texturePosition: { value: null },
                color: { value: new THREE.Color(CONFIG.color) },
                opacity: { value: CONFIG.opacity },
                size: { value: CONFIG.pointSize },
                scale: { value: def.scale || 1.0 }
            };

            material = new THREE.ShaderMaterial({
                uniforms: uniformsMat,
                vertexShader: `
                    uniform sampler2D texturePosition;
                    uniform float size;
                    uniform float scale;
                    varying vec3 vPos;
                    void main() {
                        vec4 pos = texture2D(texturePosition, uv);
                        vPos = pos.xyz;
                        vec4 mvPosition = modelViewMatrix * vec4(pos.xyz * scale, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float opacity;
                    void main() {
                        // Circular particle
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        if(length(coord) > 0.5) discard;
                        gl_FragColor = vec4(color, opacity);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);
        }

        function fillTexture(texture, name) {
            const data = texture.image.data;
            const def = ATTRACTORS[name];
            // Initialize with random noise or specific start
            for (let i = 0; i < data.length; i += 4) {
                data[i] = (Math.random() - 0.5) * 10;
                data[i + 1] = (Math.random() - 0.5) * 10;
                data[i + 2] = (Math.random() - 0.5) * 10;
                data[i + 3] = 1;
            }
        }

        function onWindowResize() {
            if (isExporting) return; // Don't mess with resize during export
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isExporting) return; // Export loop handles rendering

            render();
        }

        function render() {
            if (!gpuCompute) return;

            // Update Uniforms
            const def = ATTRACTORS[CONFIG.attractor];
            positionVariable.material.uniforms.dt.value = def.dt * CONFIG.speed;

            // Compute
            gpuCompute.compute();

            // Update Material
            material.uniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
            material.uniforms.color.value.set(CONFIG.color);
            material.uniforms.opacity.value = CONFIG.opacity;
            material.uniforms.size.value = CONFIG.pointSize;

            // Rotate
            if (CONFIG.autoRotate) {
                scene.rotation.y += CONFIG.rotationSpeed * 0.01;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // --- Export Logic ---
        async function startExport() {
            if (isExporting) return;
            isExporting = true;
            
            const overlay = document.getElementById('overlay');
            const progressFill = document.getElementById('progress-fill');
            const statusText = document.getElementById('export-status');
            overlay.style.display = 'flex';
            
            // 1. Setup Encoder
            const width = parseInt(CONFIG.exportWidth);
            const height = parseInt(CONFIG.exportHeight);
            const fps = CONFIG.exportFps;
            const duration = CONFIG.exportDuration;
            const bitrate = CONFIG.exportBitrate * 1_000_000;
            
            const muxer = new Mp4Muxer.Muxer({
                target: new Mp4Muxer.ArrayBufferTarget(),
                video: {
                    codec: 'avc',
                    width: width,
                    height: height
                },
                fastStart: 'in-memory'
            });

            const videoEncoder = new VideoEncoder({
                output: (chunk, meta) => muxer.addVideoChunk(chunk, meta),
                error: (e) => { console.error(e); alert("Encoding Error: " + e.message); }
            });

            videoEncoder.configure({
                codec: 'avc1.42E033', // Constrained Baseline, Level 5.1
                width: width,
                height: height,
                bitrate: bitrate,
                framerate: fps,
                avc: { format: 'avc' }
            });

            // 2. Resize Renderer
            const originalSize = new THREE.Vector2();
            renderer.getSize(originalSize);
            const originalPixelRatio = renderer.getPixelRatio();
            const originalAspect = camera.aspect;

            // Force 1.0 pixel ratio for export to ensure exact dimensions
            renderer.setPixelRatio(1);
            // Resize buffer only, keep CSS size to avoid layout thrashing (though overlay covers it)
            renderer.setSize(width, height, false);
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            // 3. Render Loop
            const totalFrames = duration * fps;
            
            try {
                for (let i = 0; i < totalFrames; i++) {
                    // Update Progress
                    const pct = Math.round((i / totalFrames) * 100);
                    progressFill.style.width = pct + "%";
                    statusText.innerText = `Rendering Frame ${i}/${totalFrames}`;
                    
                    // Wait for UI update
                    await new Promise(r => setTimeout(r, 0));

                    // Step Simulation
                    const def = ATTRACTORS[CONFIG.attractor];
                    positionVariable.material.uniforms.dt.value = def.dt * CONFIG.speed;
                    gpuCompute.compute();
                    material.uniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
                    
                    // Rotate
                    if (CONFIG.autoRotate) {
                        scene.rotation.y += CONFIG.rotationSpeed * 0.01; 
                    }

                    // Render
                    renderer.render(scene, camera);

                    // Encode
                    const timestamp = Math.round(i * 1000000 / fps);
                    const frameDuration = Math.round(1000000 / fps);
                    const frame = new VideoFrame(renderer.domElement, { 
                        timestamp: timestamp,
                        duration: frameDuration
                    });
                    videoEncoder.encode(frame, { keyFrame: i % (fps * 2) === 0 });
                    frame.close();
                }

                await videoEncoder.flush();
                muxer.finalize();

                // 5. Remux with FFmpeg to fix SPS/PPS headers
                statusText.innerText = "Loading FFmpeg...";
                await new Promise(r => setTimeout(r, 50));

                // Check for COOP/COEP
                if (!window.crossOriginIsolated) {
                    console.warn("Page is not cross-origin isolated. FFmpeg might be slow or fail.");
                }

                const { FFmpeg } = FFmpegWASM;
                const ffmpeg = new FFmpeg();
                
                ffmpeg.on('log', ({ message }) => {
                    console.log("FFmpeg:", message);
                    // Update status only for major steps to avoid flickering
                    if(message.includes("Loading") || message.includes("muxing")) {
                         statusText.innerText = "FFmpeg: " + message;
                    }
                });

                // Load single-threaded core to avoid SharedArrayBuffer issues
                // We load the WASM from CDN because it exceeds Cloudflare Workers 25MB limit
                await ffmpeg.load({
                    coreURL: "/vendor/ffmpeg/ffmpeg-core.js",
                    wasmURL: "https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.wasm"
                });

                statusText.innerText = "Remuxing Video...";
                await ffmpeg.writeFile('input.mp4', new Uint8Array(muxer.target.buffer));
                
                // -c copy is extremely fast and preserves quality exactly
                // We use a simple copy but force the container to be rewritten
                // The previous filters failed because the input header is too broken to parse
                // So we just copy the stream blindly into a new container, which usually fixes the index
                
                try {
                    // We need to force the SPS ID to 0 to match the container expectation
                    // h264_metadata filter can do this by deleting the filler and potentially rewriting the header
                    // But since that failed, we will try a different approach:
                    // Extract raw stream first, then mux it back.
                    
                    await ffmpeg.exec(['-i', 'input.mp4', '-c', 'copy', '-bsf:v', 'h264_mp4toannexb', 'temp.h264']);
                    // When muxing from raw h264, we MUST specify the framerate, otherwise it defaults to 25fps or garbage
                    await ffmpeg.exec(['-r', fps.toString(), '-i', 'temp.h264', '-c', 'copy', '-movflags', '+faststart', 'output.mp4']);
                    
                } catch (e) {
                    // Ignore Aborted() error if output exists, it's a known ffmpeg.wasm quirk
                    console.warn("FFmpeg exec threw error (likely Aborted), checking for output...", e);
                }
                
                statusText.innerText = "Reading Output...";
                const data = await ffmpeg.readFile('output.mp4');

                // 6. Download
                const blob = new Blob([data.buffer], { type: 'video/mp4' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `attractor_${CONFIG.attractor}_${width}x${height}.mp4`;
                a.click();
                URL.revokeObjectURL(url);

            } catch (err) {
                console.error(err);
                alert("Export failed: " + err.message);
            } finally {
                // 5. Restore
                renderer.setPixelRatio(originalPixelRatio);
                renderer.setSize(originalSize.x, originalSize.y, true); // Restore style too
                camera.aspect = originalAspect;
                camera.updateProjectionMatrix();
                
                overlay.style.display = 'none';
                isExporting = false;
                
                animate();
            }
        }

        init();
    </script>
</body>
</html>
