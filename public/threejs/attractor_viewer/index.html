<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaotic Attractor Viewer V2</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #ccc; font-family: monospace; }
        #ui-container { position: absolute; top: 10px; right: 10px; }
        #status { position: absolute; bottom: 10px; left: 10px; pointer-events: none; text-shadow: 0 0 2px #000; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none;
            justify-content: center; align-items: center; flex-direction: column;
            z-index: 100;
        }
        #progress-bar {
            width: 300px; height: 20px; background: #333; border: 1px solid #555; margin-top: 10px;
        }
        #progress-fill {
            width: 0%; height: 100%; background: #00ffff; transition: width 0.1s;
        }
    </style>
</head>
<body>
    <div id="status">Initializing...</div>
    <div id="overlay">
        <div id="export-status">Rendering Video...</div>
        <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>

    <script src="https://unpkg.com/ccapture.js@1.1.0/build/CCapture.all.min.js"></script>
    <script src="/vendor/ffmpeg/ffmpeg.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js",
            "mp4-muxer": "https://cdn.jsdelivr.net/npm/mp4-muxer@5.1.0/build/mp4-muxer.mjs",
            "tone": "https://cdn.jsdelivr.net/npm/tone@14.7.77/+esm"
        }
    }
    </script>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { GPUComputationRenderer } from "three/addons/misc/GPUComputationRenderer.js";
        import GUI from "lil-gui";
        import * as Mp4Muxer from "mp4-muxer";
        import { AudioEngine, bufferToWave } from "./audio.js";

        // --- Configuration & State ---
        const CONFIG = {
            attractor: 'thomas',
            particleCount: 1024, // Texture size (1024x1024 = 1M)
            opacity: 0.1,
            pointSize: 0.05,
            color: "#00ffff",
            speed: 1.0,
            
            // Visuals
            focus: 10.0,
            aperture: 0.0,

            // Camera
            rotationSpeed: 0.2,
            autoRotate: true,

            // Audio
            audioEnabled: false,
            audioVolume: -10,
            audioBpm: 60,
            audioPattern: "Ethereal",

            // Export
            exportWidth: 1080,
            exportHeight: 1920,
            exportFps: 60,
            exportDuration: 10,
            exportBitrate: 20, // Mbps
        };

        // --- Shaders ---
        const SHADERS = {
            clifford: `
                uniform float a;
                uniform float b;
                uniform float c;
                uniform float d;
                uniform float e;
                uniform float f;
                uniform float seed;
                
                float rand(vec2 co){
                    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
                }
                
                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 pos = texture2D(texturePosition, uv);
                    
                    float nx = sin(a * pos.y) + c * cos(a * pos.x);
                    float ny = sin(b * pos.x) + d * cos(b * pos.y);
                    float nz = sin(e * pos.x) + f * cos(e * pos.z);
                    
                    vec3 noise = vec3(
                        rand(uv + seed) - 0.5,
                        rand(uv + seed + 1.1) - 0.5,
                        rand(uv + seed + 2.2) - 0.5
                    ) * 0.002;
                    
                    gl_FragColor = vec4(vec3(nx, ny, nz) + noise, 1.0);
                }
            `,
            bedhead: `
                uniform float a;
                uniform float b;
                uniform float seed;
                
                float rand(vec2 co){
                    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
                }
                
                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 pos = texture2D(texturePosition, uv);
                    
                    float nx = sin(pos.x * pos.y / b) * pos.y + cos(a * pos.x - pos.z);
                    float ny = pos.z + sin(pos.y) / b;
                    float nz = pos.x + sin(pos.z) / b;
                    
                    vec3 noise = vec3(
                        rand(uv + seed) - 0.5,
                        rand(uv + seed + 1.1) - 0.5,
                        rand(uv + seed + 2.2) - 0.5
                    ) * 0.002;
                    
                    gl_FragColor = vec4(vec3(nx, ny, nz) + noise, 1.0);
                }
            `,
            halvorsen: `
                uniform float a;
                uniform float dt;
                uniform float seed;

                float rand(vec2 co){
                    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
                }

                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 pos = texture2D(texturePosition, uv);
                    
                    float x = pos.x;
                    float y = pos.y;
                    float z = pos.z;
                    
                    float dx = -a*x - 4.0*y - 4.0*z - y*y;
                    float dy = -a*y - 4.0*z - 4.0*x - z*z;
                    float dz = -a*z - 4.0*x - 4.0*y - x*x;
                    
                    vec3 next = pos.xyz + vec3(dx, dy, dz) * dt;
                    
                    if (length(next) > 20.0) {
                        vec3 noise = vec3(
                            rand(uv + seed) - 0.5,
                            rand(uv + seed + 1.1) - 0.5,
                            rand(uv + seed + 2.2) - 0.5
                        ) * 2.0;
                        next = noise;
                    }
                    
                    gl_FragColor = vec4(next, 1.0);
                }
            `,
            thomas: `
                uniform float b;
                uniform float dt;
                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 pos = texture2D(texturePosition, uv);
                    float dx = sin(pos.y) - b * pos.x;
                    float dy = sin(pos.z) - b * pos.y;
                    float dz = sin(pos.x) - b * pos.z;
                    vec3 next = pos.xyz + vec3(dx, dy, dz) * dt;
                    gl_FragColor = vec4(next, 1.0);
                }
            `,
            aizawa: `
                uniform float a;
                uniform float b;
                uniform float c;
                uniform float d;
                uniform float e;
                uniform float f;
                uniform float dt;
                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 pos = texture2D(texturePosition, uv);
                    float x = pos.x; float y = pos.y; float z = pos.z;
                    float dx = (z - b) * x - d * y;
                    float dy = d * x + (z - b) * y;
                    float dz = c + a * z - (z * z * z / 3.0) - (x * x + y * y) * (1.0 + e * z) + f * z * x * x * x;
                    vec3 next = pos.xyz + vec3(dx, dy, dz) * dt;
                    gl_FragColor = vec4(next, 1.0);
                }
            `,
            lorenz: `
                uniform float sigma;
                uniform float rho;
                uniform float beta;
                uniform float dt;
                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 pos = texture2D(texturePosition, uv);
                    float x = pos.x; float y = pos.y; float z = pos.z;
                    float dx = sigma * (y - x);
                    float dy = x * (rho - z) - y;
                    float dz = x * y - beta * z;
                    vec3 next = pos.xyz + vec3(dx, dy, dz) * dt;
                    gl_FragColor = vec4(next, 1.0);
                }
            `
        };

        const ATTRACTORS = {
            clifford: {
                defaults: { a: 1.5, b: -1.8, c: 1.6, d: 0.9, e: 1.0, f: 0.5 },
                ranges: { a: [-3, 3], b: [-3, 3], c: [-3, 3], d: [-3, 3], e: [-3, 3], f: [-3, 3] },
                shader: SHADERS.clifford,
                scale: 1.0,
                dt: 1.0
            },
            bedhead: {
                defaults: { a: 1, b: 1 },
                ranges: { a: [-1, 1], b: [-1, 1] },
                shader: SHADERS.bedhead,
                scale: 1.0,
                dt: 1.0
            },
            halvorsen: {
                defaults: { a: 1.4 },
                ranges: { a: [0, 5] },
                shader: SHADERS.halvorsen,
                scale: 0.5,
                dt: 0.01
            },
            thomas: {
                defaults: { b: 0.208186 },
                ranges: { b: [0, 1] },
                shader: SHADERS.thomas,
                scale: 0.5,
                dt: 0.1
            },
            aizawa: {
                defaults: { a: 0.95, b: 0.7, c: 0.6, d: 3.5, e: 0.25, f: 0.1 },
                ranges: { a: [0, 1], b: [0, 1], c: [0, 1], d: [0, 5], e: [0, 1], f: [0, 1] },
                shader: SHADERS.aizawa,
                scale: 2.0,
                dt: 0.01
            },
            lorenz: {
                defaults: { sigma: 10.0, rho: 28.0, beta: 2.6666 },
                ranges: { sigma: [0, 50], rho: [0, 100], beta: [0, 10] },
                shader: SHADERS.lorenz,
                scale: 1.0,
                dt: 0.005
            }
        };

        // --- Globals ---
        let scene, camera, renderer, controls;
        let gpuCompute, positionVariable;
        let points, material;
        let gui;
        let attractorParams = {};
        let isExporting = false;
        let oscillators = [];
        let time = 0;
        let colormapTexture, colormapNames;
        let colormapConfig = {
            name: 'viridis',
            mode: 0, // 0: Solid, 1: Velocity, 2: Position, 3: Index
            scale: 1.0,
            offset: 0.0
        };
        let audioEngine;

        // --- Initialization ---
        async function loadColormaps() {
            try {
                const response = await fetch('colormaps.json');
                const data = await response.json();
                colormapNames = Object.keys(data);
                const width = 256;
                const height = colormapNames.length;
                const size = width * height * 4;
                const pixelData = new Uint8Array(size);

                colormapNames.forEach((name, rowIndex) => {
                    const colors = data[name];
                    for (let i = 0; i < width; i++) {
                        const color = colors[i];
                        const stride = (rowIndex * width + i) * 4;
                        pixelData[stride] = Math.floor(color[0] * 255);
                        pixelData[stride + 1] = Math.floor(color[1] * 255);
                        pixelData[stride + 2] = Math.floor(color[2] * 255);
                        pixelData[stride + 3] = 255;
                    }
                });

                colormapTexture = new THREE.DataTexture(pixelData, width, height, THREE.RGBAFormat);
                colormapTexture.needsUpdate = true;
                colormapTexture.minFilter = THREE.LinearFilter;
                colormapTexture.magFilter = THREE.LinearFilter;
                return true;
            } catch (e) {
                console.error("Failed to load colormaps", e);
                return false;
            }
        }

        function addOscillator(folder) {
            const osc = {
                id: Math.random().toString(36).substr(2, 9),
                targetParam: Object.keys(attractorParams)[0],
                type: "sin",
                amp: 0.5,
                freq: 0.5,
                phase: 0,
                base: attractorParams[Object.keys(attractorParams)[0]]
            };
            oscillators.push(osc);
            
            const sub = folder.addFolder(`Osc ${oscillators.length}`);
            sub.add(osc, "targetParam", Object.keys(attractorParams));
            sub.add(osc, "type", ["sin", "cos"]);
            sub.add(osc, "amp", 0, 5);
            sub.add(osc, "freq", 0, 5);
            sub.add(osc, "phase", 0, Math.PI * 2);
            sub.add({ remove: () => {
                oscillators = oscillators.filter(o => o.id !== osc.id);
                sub.destroy();
            }}, "remove");
        }

        async function init() {
            await loadColormaps();

            const container = document.createElement('div');
            document.body.appendChild(container);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false }); // Antialias off for particles usually better perf
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // GUI
            gui = new GUI({ title: "Attractor Settings" });
            setupGui();

            // Initial Setup
            changeAttractor(CONFIG.attractor);

            // Events
            window.addEventListener('resize', onWindowResize);
            
            // Start Loop
            animate();
            
            document.getElementById('status').innerText = "Ready.";
        }

        function resetParticles() {
            if (!gpuCompute || !positionVariable) return;
            const dtPosition = gpuCompute.createTexture();
            fillTexture(dtPosition, CONFIG.attractor);
            gpuCompute.renderTexture(dtPosition, positionVariable.renderTargets[0]);
            gpuCompute.renderTexture(dtPosition, positionVariable.renderTargets[1]);
            time = 0;
        }

        function setupGui() {
            const mainFolder = gui.addFolder("General");
            mainFolder.add(CONFIG, 'attractor', Object.keys(ATTRACTORS)).onChange(changeAttractor);
            mainFolder.add({ reset: resetParticles }, 'reset').name("Reset Simulation");
            mainFolder.add(CONFIG, 'speed', 0, 5);
            mainFolder.add(CONFIG, 'autoRotate');
            mainFolder.add(CONFIG, 'rotationSpeed', 0, 2);

            const visFolder = gui.addFolder("Visuals & Particles");
            
            // Resolution / Particle Count
            const resolutions = {
                'Low (250k)': 512,
                'Medium (1M)': 1024,
                'High (4M)': 2048
            };
            visFolder.add(CONFIG, 'particleCount', resolutions).name('Particle Count').onChange(val => {
                CONFIG.particleCount = parseInt(val);
                changeAttractor(CONFIG.attractor);
            });

            visFolder.addColor(CONFIG, 'color').onChange(v => { if(material) material.uniforms.color.value.set(v); });
            visFolder.add(CONFIG, 'opacity', 0.01, 1.0).onChange(v => { if(material) material.uniforms.opacity.value = v; });
            visFolder.add(CONFIG, 'pointSize', 0.01, 0.5).onChange(v => { if(material) material.uniforms.size.value = v; });
            visFolder.add(CONFIG, 'focus', 0.1, 50.0).onChange(v => { if(material) material.uniforms.focus.value = v; }).name("Focus Dist");
            visFolder.add(CONFIG, 'aperture', 0.0, 0.5).onChange(v => { if(material) material.uniforms.aperture.value = v; }).name("Aperture (Blur)");

            const colorFolder = gui.addFolder("Coloring");
            // We need to wait for colormaps to load to populate the dropdown, or update it later.
            // Since init calls loadColormaps before setupGui (wait, init calls setupGui), 
            // actually init calls setupGui BEFORE loadColormaps finishes because loadColormaps is async and init awaits it?
            // No, init is async and awaits loadColormaps. So colormapNames should be available.
            
            if (colormapNames && colormapNames.length > 0) {
                colorFolder.add(colormapConfig, 'name', colormapNames).name('Colormap');
            }
            colorFolder.add(colormapConfig, 'mode', { 'Solid': 0, 'Velocity': 1, 'Position': 2, 'Index': 3 }).name('Mode');
            colorFolder.add(colormapConfig, 'scale', 0.01, 5.0).name('Scale');
            colorFolder.add(colormapConfig, 'offset', -5.0, 5.0).name('Offset');

            gui.folders_oscillators = gui.addFolder("Oscillators");
            gui.folders_oscillators.add({ add: () => addOscillator(gui.folders_oscillators) }, "add").name("Add Oscillator");

            const audioFolder = gui.addFolder("Audio (Tone.js)");
            audioFolder.add(CONFIG, 'audioEnabled').name("Enable Audio").onChange(async v => {
                if (v) {
                    if (!audioEngine) {
                        audioEngine = new AudioEngine();
                        await audioEngine.init();
                    }
                    audioEngine.start();
                } else {
                    if (audioEngine) audioEngine.stop();
                }
            });
            audioFolder.add(CONFIG, 'audioVolume', -60, 0).name("Master Vol (dB)").onChange(v => {
                if(audioEngine) audioEngine.setMasterVolume(v);
            });
            audioFolder.add(CONFIG, 'audioBpm', 30, 200).name("BPM").onChange(v => {
                if(audioEngine) audioEngine.setParam('bpm', v);
            });
            audioFolder.add(CONFIG, 'audioPattern', ["Ethereal", "Dark Space", "Mystery", "Drone"]).name("Pattern").onChange(v => {
                if(audioEngine) audioEngine.setPattern(v);
            });
            
            const instFolder = audioFolder.addFolder("Instruments");
            instFolder.add({ pad: -12 }, 'pad', -60, 0).onChange(v => audioEngine && audioEngine.setVolume('pad', v));
            instFolder.add({ keys: -10 }, 'keys', -60, 0).onChange(v => audioEngine && audioEngine.setVolume('keys', v));
            instFolder.add({ bass: -8 }, 'bass', -60, 0).onChange(v => audioEngine && audioEngine.setVolume('bass', v));
            
            const fxFolder = audioFolder.addFolder("Effects");
            fxFolder.add({ reverb: 0.5 }, 'reverb', 0, 1).onChange(v => audioEngine && audioEngine.setParam('reverb', v));
            fxFolder.add({ delay: 0.3 }, 'delay', 0, 1).onChange(v => audioEngine && audioEngine.setParam('delay', v));

            const exportFolder = gui.addFolder("Export Video");
            exportFolder.add(CONFIG, 'exportWidth', [720, 1080, 1920, 2160, 3840]);
            exportFolder.add(CONFIG, 'exportHeight', [720, 1080, 1920, 2160, 3840]);
            exportFolder.add(CONFIG, 'exportFps', [30, 60]);
            exportFolder.add(CONFIG, 'exportDuration', 1, 60).name("Duration (s)");
            exportFolder.add(CONFIG, 'exportBitrate', 1, 100).name("Bitrate (Mbps)");
            exportFolder.add({ export: startExport }, 'export').name("START EXPORT");
        }

        function changeAttractor(name) {
            const def = ATTRACTORS[name];
            if (!def) return;

            // Cleanup old GPGPU
            if (gpuCompute) {
                // Dispose logic if needed
            }

            // Init GPGPU
            const size = CONFIG.particleCount;
            gpuCompute = new GPUComputationRenderer(size, size, renderer);

            const dtPosition = gpuCompute.createTexture();
            fillTexture(dtPosition, name);

            positionVariable = gpuCompute.addVariable("texturePosition", def.shader, dtPosition);
            gpuCompute.setVariableDependencies(positionVariable, [positionVariable]);

            // Uniforms
            attractorParams = { ...def.defaults };
            const uniforms = positionVariable.material.uniforms;
            uniforms["dt"] = { value: def.dt * CONFIG.speed };
            
            // Add params to GUI
            // Remove old param folder if exists
            if (gui.folders_params) gui.folders_params.destroy();
            gui.folders_params = gui.addFolder(name + " Parameters");
            
            for (const key in def.defaults) {
                uniforms[key] = { value: def.defaults[key] };
                gui.folders_params.add(attractorParams, key, def.ranges[key][0], def.ranges[key][1]).onChange(v => {
                    uniforms[key].value = v;
                });
            }

            // Reset Oscillators
            oscillators = [];
            if (gui.folders_oscillators) {
                gui.folders_oscillators.destroy();
                gui.folders_oscillators = gui.addFolder("Oscillators");
                gui.folders_oscillators.add({ add: () => addOscillator(gui.folders_oscillators) }, "add").name("Add Oscillator");
            }

            const error = gpuCompute.init();
            if (error !== null) {
                console.error(error);
            }

            // Create Particles
            if (points) scene.remove(points);
            
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(size * size * 3);
            const uvs = new Float32Array(size * size * 2);
            
            for (let i = 0; i < size * size; i++) {
                positions[i * 3] = 0;
                positions[i * 3 + 1] = 0;
                positions[i * 3 + 2] = 0;
                
                const x = (i % size) / size;
                const y = Math.floor(i / size) / size;
                uvs[i * 2] = x;
                uvs[i * 2 + 1] = y;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

            // Material
            // We need a custom shader material to read from the GPGPU texture
            
            // Calculate initial colormap row
            let row = 0.5;
            if (colormapNames && colormapNames.length > 0) {
                const idx = colormapNames.indexOf(colormapConfig.name);
                if (idx >= 0) row = (idx + 0.5) / colormapNames.length;
            }

            const uniformsMat = {
                texturePosition: { value: null },
                texturePrevPosition: { value: null },
                color: { value: new THREE.Color(CONFIG.color) },
                opacity: { value: CONFIG.opacity },
                size: { value: CONFIG.pointSize },
                scale: { value: def.scale || 1.0 },
                focus: { value: CONFIG.focus },
                aperture: { value: CONFIG.aperture },
                
                // Coloring
                colormapTexture: { value: colormapTexture },
                colormapRow: { value: row },
                colorMode: { value: colormapConfig.mode },
                colorScale: { value: colormapConfig.scale },
                colorOffset: { value: colormapConfig.offset }
            };

            material = new THREE.ShaderMaterial({
                uniforms: uniformsMat,
                vertexShader: `
                    uniform sampler2D texturePosition;
                    uniform sampler2D texturePrevPosition;
                    uniform float size;
                    uniform float scale;
                    uniform float focus;
                    uniform float aperture;
                    
                    uniform int colorMode;
                    uniform float colorScale;
                    uniform float colorOffset;
                    
                    varying float vColorVal;
                    varying float vAlpha;
                    
                    void main() {
                        vec4 pos = texture2D(texturePosition, uv);
                        vec4 prevPos = texture2D(texturePrevPosition, uv);
                        vec4 mvPosition = modelViewMatrix * vec4(pos.xyz * scale, 1.0);
                        
                        // Color Value Calculation
                        if (colorMode == 1) {
                            // Velocity (Speed)
                            float speed = distance(pos.xyz, prevPos.xyz);
                            vColorVal = speed * colorScale + colorOffset;
                        } else if (colorMode == 2) {
                            // Position (Radius)
                            float dist = length(pos.xyz);
                            vColorVal = dist * colorScale + colorOffset;
                        } else if (colorMode == 3) {
                            // Index (UV)
                            vColorVal = uv.x * colorScale + colorOffset;
                        } else {
                            vColorVal = 0.0;
                        }
                        
                        // Depth of Field Calculation
                        float dist = -mvPosition.z;
                        float coc = abs(dist - focus) * aperture;
                        
                        // Fade out blurred points more aggressively
                        vAlpha = 1.0 / (1.0 + coc * 20.0);
                        
                        gl_PointSize = (size + coc) * (300.0 / dist);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float opacity;
                    uniform sampler2D colormapTexture;
                    uniform float colormapRow;
                    uniform int colorMode;
                    
                    varying float vColorVal;
                    varying float vAlpha;
                    
                    void main() {
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        float dist = length(coord);
                        if(dist > 0.5) discard;
                        
                        float strength = 1.0 - (dist * 2.0);
                        strength = pow(strength, 2.0);
                        
                        vec3 finalColor = color;
                        if (colorMode > 0) {
                            float c = clamp(vColorVal, 0.0, 1.0);
                            finalColor = texture2D(colormapTexture, vec2(c, colormapRow)).rgb;
                        }
                        
                        gl_FragColor = vec4(finalColor, opacity * strength * vAlpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);
        }

        function fillTexture(texture, name) {
            const data = texture.image.data;
            const def = ATTRACTORS[name];
            const scale = (def.scale || 1.0) * 4.0; // Match index.html logic roughly (4 * scale)

            // Initialize with random noise
            for (let i = 0; i < data.length; i += 4) {
                data[i] = (Math.random() - 0.5) * scale;
                data[i + 1] = (Math.random() - 0.5) * scale;
                data[i + 2] = (Math.random() - 0.5) * scale;
                data[i + 3] = 1;
            }
        }

        function onWindowResize() {
            if (isExporting) return; // Don't mess with resize during export
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isExporting) return; // Export loop handles rendering

            render();
        }

        function updateParameters(dt) {
            // Update Oscillators
            oscillators.forEach(osc => {
                if (attractorParams.hasOwnProperty(osc.targetParam)) {
                    const t = time * osc.freq + osc.phase;
                    let val = 0;
                    if (osc.type === "sin") val = Math.sin(t);
                    if (osc.type === "cos") val = Math.cos(t);
                    attractorParams[osc.targetParam] = osc.base + val * osc.amp;
                }
            });

            // Update Shader Uniforms
            const uniforms = positionVariable.material.uniforms;
            for(let key in attractorParams) {
                if(uniforms[key]) uniforms[key].value = attractorParams[key];
            }
            if(uniforms['dt']) uniforms['dt'].value = dt;
            if(uniforms['seed']) uniforms['seed'].value = time;
        }

        function render() {
            if (!gpuCompute) return;

            const dt = 0.016 * CONFIG.speed;
            time += dt;

            updateParameters(dt);

            // Compute
            gpuCompute.compute();

            // Update Material
            material.uniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
            material.uniforms.texturePrevPosition.value = gpuCompute.getAlternateRenderTarget(positionVariable).texture;
            
            material.uniforms.color.value.set(CONFIG.color);
            material.uniforms.opacity.value = CONFIG.opacity;
            material.uniforms.size.value = CONFIG.pointSize;
            material.uniforms.focus.value = CONFIG.focus;
            material.uniforms.aperture.value = CONFIG.aperture;

            // Colormap Uniforms
            if (colormapNames && colormapNames.length > 0) {
                 const idx = colormapNames.indexOf(colormapConfig.name);
                 if (idx >= 0) material.uniforms.colormapRow.value = (idx + 0.5) / colormapNames.length;
            }
            material.uniforms.colorMode.value = colormapConfig.mode;
            material.uniforms.colorScale.value = colormapConfig.scale;
            material.uniforms.colorOffset.value = colormapConfig.offset;

            // Rotate
            if (CONFIG.autoRotate) {
                scene.rotation.y += CONFIG.rotationSpeed * 0.01;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // --- Export Logic ---
        async function startExport() {
            if (isExporting) return;
            isExporting = true;
            
            const overlay = document.getElementById('overlay');
            const progressFill = document.getElementById('progress-fill');
            const statusText = document.getElementById('export-status');
            overlay.style.display = 'flex';
            
            // 1. Setup Encoder
            const width = parseInt(CONFIG.exportWidth);
            const height = parseInt(CONFIG.exportHeight);
            const fps = CONFIG.exportFps;
            const duration = CONFIG.exportDuration;
            const bitrate = CONFIG.exportBitrate * 1_000_000;
            
            const muxer = new Mp4Muxer.Muxer({
                target: new Mp4Muxer.ArrayBufferTarget(),
                video: {
                    codec: 'avc',
                    width: width,
                    height: height
                },
                fastStart: 'in-memory'
            });

            const videoEncoder = new VideoEncoder({
                output: (chunk, meta) => muxer.addVideoChunk(chunk, meta),
                error: (e) => { console.error(e); alert("Encoding Error: " + e.message); }
            });

            videoEncoder.configure({
                codec: 'avc1.42E033', // Constrained Baseline, Level 5.1
                width: width,
                height: height,
                bitrate: bitrate,
                framerate: fps,
                avc: { format: 'avc' }
            });

            // 2. Resize Renderer
            const originalSize = new THREE.Vector2();
            renderer.getSize(originalSize);
            const originalPixelRatio = renderer.getPixelRatio();
            const originalAspect = camera.aspect;

            // Force 1.0 pixel ratio for export to ensure exact dimensions
            renderer.setPixelRatio(1);
            // Resize buffer only, keep CSS size to avoid layout thrashing (though overlay covers it)
            renderer.setSize(width, height, false);
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            // 3. Render Loop
            const totalFrames = duration * fps;
            
            try {
                for (let i = 0; i < totalFrames; i++) {
                    // Update Progress
                    const pct = Math.round((i / totalFrames) * 100);
                    progressFill.style.width = pct + "%";
                    statusText.innerText = `Rendering Frame ${i}/${totalFrames}`;
                    
                    // Wait for UI update
                    await new Promise(r => setTimeout(r, 0));

                    // Step Simulation
                    const dt = (1 / fps) * CONFIG.speed;
                    time += dt;
                    updateParameters(dt);
                    
                    gpuCompute.compute();
                    material.uniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
                    material.uniforms.texturePrevPosition.value = gpuCompute.getAlternateRenderTarget(positionVariable).texture;
                    
                    // Colormap Uniforms
                    if (colormapNames && colormapNames.length > 0) {
                        const idx = colormapNames.indexOf(colormapConfig.name);
                        if (idx >= 0) material.uniforms.colormapRow.value = (idx + 0.5) / colormapNames.length;
                    }
                    material.uniforms.colorMode.value = colormapConfig.mode;
                    material.uniforms.colorScale.value = colormapConfig.scale;
                    material.uniforms.colorOffset.value = colormapConfig.offset;
                    
                    // Rotate
                    if (CONFIG.autoRotate) {
                        scene.rotation.y += CONFIG.rotationSpeed * 0.01; 
                    }

                    // Render
                    renderer.render(scene, camera);

                    // Encode
                    const timestamp = Math.round(i * 1000000 / fps);
                    const frameDuration = Math.round(1000000 / fps);
                    const frame = new VideoFrame(renderer.domElement, { 
                        timestamp: timestamp,
                        duration: frameDuration
                    });
                    videoEncoder.encode(frame, { keyFrame: i % (fps * 2) === 0 });
                    frame.close();
                }

                await videoEncoder.flush();
                muxer.finalize();

                // 5. Remux with FFmpeg to fix SPS/PPS headers
                statusText.innerText = "Loading FFmpeg...";
                await new Promise(r => setTimeout(r, 50));

                // Check for COOP/COEP
                if (!window.crossOriginIsolated) {
                    console.warn("Page is not cross-origin isolated. FFmpeg might be slow or fail.");
                }

                const { FFmpeg } = FFmpegWASM;
                const ffmpeg = new FFmpeg();
                
                ffmpeg.on('log', ({ message }) => {
                    console.log("FFmpeg:", message);
                    // Update status only for major steps to avoid flickering
                    if(message.includes("Loading") || message.includes("muxing")) {
                         statusText.innerText = "FFmpeg: " + message;
                    }
                });

                // Load single-threaded core to avoid SharedArrayBuffer issues
                // We load the WASM from CDN because it exceeds Cloudflare Workers 25MB limit
                // Added ?v=cachebust to force reload after browser crash
                await ffmpeg.load({
                    coreURL: "/vendor/ffmpeg/ffmpeg-core.js",
                    wasmURL: "https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.wasm?v=cachebust_1"
                });

                // --- Audio Rendering ---
                let audioFile = null;
                if (CONFIG.audioEnabled && audioEngine) {
                    statusText.innerText = "Rendering Audio...";
                    // Render offline audio
                    const audioBuffer = await audioEngine.renderOffline(duration);
                    
                    // Convert to WAV
                    // We need to import bufferToWave from audio.js or define it here.
                    // Since it's exported from audio.js, we can use it if we imported it.
                    // But index.html imports AudioEngine, not bufferToWave.
                    // Let's assume we update the import or just copy the helper here for simplicity if needed,
                    // but better to import it.
                    
                    // Wait, we need to update the import statement at the top first.
                    // Let's assume we will update the import to: import { AudioEngine, bufferToWave } from "./audio.js";
                    
                    const wavData = bufferToWave(audioBuffer, audioBuffer.length);
                    await ffmpeg.writeFile('audio.wav', new Uint8Array(wavData));
                    audioFile = 'audio.wav';
                }

                statusText.innerText = "Remuxing Video...";
                await ffmpeg.writeFile('input.mp4', new Uint8Array(muxer.target.buffer));
                
                // -c copy is extremely fast and preserves quality exactly
                // We use a simple copy but force the container to be rewritten
                // The previous filters failed because the input header is too broken to parse
                // So we just copy the stream blindly into a new container, which usually fixes the index
                
                try {
                    // We need to force the SPS ID to 0 to match the container expectation
                    // h264_metadata filter can do this by deleting the filler and potentially rewriting the header
                    // But since that failed, we will try a different approach:
                    // Extract raw stream first, then mux it back.
                    
                    await ffmpeg.exec(['-i', 'input.mp4', '-c', 'copy', '-bsf:v', 'h264_mp4toannexb', 'temp.h264']);
                    
                    // Mux back to MP4
                    const args = ['-r', fps.toString(), '-i', 'temp.h264'];
                    
                    if (audioFile) {
                        args.push('-i', audioFile);
                        // Map video from 0:0 and audio from 1:0
                        // Use aac for audio
                        args.push('-c:v', 'copy', '-c:a', 'aac', '-shortest');
                    } else {
                        args.push('-c', 'copy');
                    }
                    
                    args.push('-movflags', '+faststart', 'output.mp4');
                    
                    await ffmpeg.exec(args);
                    
                } catch (e) {
                    // Ignore Aborted() error if output exists, it's a known ffmpeg.wasm quirk
                    console.warn("FFmpeg exec threw error (likely Aborted), checking for output...", e);
                }
                
                statusText.innerText = "Reading Output...";
                const data = await ffmpeg.readFile('output.mp4');

                // 6. Download
                const blob = new Blob([data.buffer], { type: 'video/mp4' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `attractor_${CONFIG.attractor}_${width}x${height}.mp4`;
                a.click();
                URL.revokeObjectURL(url);

            } catch (err) {
                console.error(err);
                alert("Export failed: " + err.message);
            } finally {
                // 5. Restore
                renderer.setPixelRatio(originalPixelRatio);
                renderer.setSize(originalSize.x, originalSize.y, true); // Restore style too
                camera.aspect = originalAspect;
                camera.updateProjectionMatrix();
                
                overlay.style.display = 'none';
                isExporting = false;
                
                animate();
            }
        }

        init();
    </script>
</body>
</html>
