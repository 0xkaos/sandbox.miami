<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hebrew Script Writer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        #info {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>Hebrew Script Writer</h1>
        <p>Path tracing test for Script Aleph (◊ê)</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer;
        let strokes = []; // Array of { line: THREE.Line, curve: THREE.Curve, points: [] }
        let isAnimating = true;
        let startTime = 0;
        const DRAW_SPEED = 0.002; // Progress per ms

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;
            camera.position.y = 0;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Grid for reference
            const gridHelper = new THREE.GridHelper(200, 20);
            gridHelper.rotation.x = Math.PI / 2;
            scene.add(gridHelper);

            createAleph();

            window.addEventListener('resize', onWindowResize);
            
            // Restart animation on click
            window.addEventListener('click', () => {
                startTime = performance.now();
                strokes.forEach(s => s.line.geometry.setDrawRange(0, 0));
            });
        }

        function createAleph() {
            // Define strokes for Script Aleph
            // Coordinates are roughly centered around 0,0
            
            // Stroke 1: The Vertical Spine (Right side)
            // Top-Right to Bottom-Right
            const stroke1 = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(20, 40, 0),   // Start
                new THREE.Vector3(25, 0, 0),    // Control (slight curve)
                new THREE.Vector3(20, -40, 0)   // End
            );

            // Stroke 2: The Curved Arm (Left side)
            // Top-Left, curving down to connect to the spine
            const stroke2 = new THREE.CubicBezierCurve3(
                new THREE.Vector3(-20, 30, 0),  // Start (Top Left)
                new THREE.Vector3(-20, 10, 0),  // Control 1 (Down)
                new THREE.Vector3(-10, -10, 0), // Control 2 (In)
                new THREE.Vector3(20, -10, 0)   // End (Connect to spine)
            );

            addStroke(stroke1, 0xff4d4d); // Red
            addStroke(stroke2, 0x4db8ff); // Blue
        }

        function addStroke(curve, color) {
            const points = curve.getPoints(100); // 100 segments
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            // Initialize draw range to 0
            geometry.setDrawRange(0, 0);

            const material = new THREE.LineBasicMaterial({ 
                color: color,
                linewidth: 5 // Note: linewidth only works in WebGL2 with specific drivers, usually 1px in Chrome
            });

            const line = new THREE.Line(geometry, material);
            scene.add(line);

            strokes.push({
                line: line,
                curve: curve,
                totalPoints: 100
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            if (startTime === 0) startTime = time;
            const elapsed = time - startTime;

            // Animation Logic
            // Draw stroke 1, then stroke 2
            
            const strokeDuration = 1000; // ms per stroke
            
            strokes.forEach((stroke, index) => {
                // Calculate start time for this stroke
                const strokeStart = index * strokeDuration;
                
                if (elapsed >= strokeStart) {
                    // Calculate progress 0 to 1
                    const progress = Math.min((elapsed - strokeStart) / strokeDuration, 1);
                    
                    // Map progress to number of points
                    const drawCount = Math.floor(progress * stroke.totalPoints);
                    stroke.line.geometry.setDrawRange(0, drawCount);
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>