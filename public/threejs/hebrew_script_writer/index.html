<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hebrew Script Writer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        #ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            pointer-events: auto;
            display: flex; flex-direction: column; gap: 10px;
        }
        select { background: #333; color: white; padding: 5px; border: 1px solid #555; font-size: 1.2em; }
        button { padding: 5px 10px; cursor: pointer; background: #444; color: white; border: 1px solid #666; }
        button:hover { background: #555; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>Hebrew Script Writer</h1>
        <select id="char-select">
            <option value="" disabled selected>Loading...</option>
        </select>
        <button id="btn-replay">Replay Animation</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer;
        let library = {};
        let currentStrokes = []; // { line: THREE.Line, totalPoints: number }
        let startTime = 0;
        let isAnimating = false;
        
        // Configuration
        const DRAW_SPEED = 0.15; // Units per millisecond
        const LINE_COLOR = 0x4db8ff; // Light Blue
        const LINE_WIDTH = 3;

        init();

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 150;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Grid
            const grid = new THREE.GridHelper(300, 30, 0x333333, 0x222222);
            grid.rotation.x = Math.PI / 2;
            scene.add(grid);

            // Load Data
            try {
                const res = await fetch('images/letters.json');
                library = await res.json();
                populateUI();
            } catch (err) {
                console.error("Failed to load letters.json", err);
            }

            window.addEventListener('resize', onWindowResize);
            document.getElementById('char-select').addEventListener('change', (e) => playCharacter(e.target.value));
            document.getElementById('btn-replay').addEventListener('click', () => {
                const val = document.getElementById('char-select').value;
                if (val) playCharacter(val);
            });

            animate();
        }

        function populateUI() {
            const select = document.getElementById('char-select');
            select.innerHTML = '<option value="" disabled selected>Select Character</option>';
            
            // Sort keys alphabetically or by some order if preferred
            Object.keys(library).sort().forEach(key => {
                const opt = document.createElement('option');
                opt.value = key;
                opt.textContent = key;
                select.appendChild(opt);
            });
        }

        function playCharacter(charName) {
            // Clear previous
            currentStrokes.forEach(s => scene.remove(s.line));
            currentStrokes = [];

            const strokesData = library[charName];
            if (!strokesData) return;

            let totalCharLength = 0;

            // Create geometry for each stroke
            strokesData.forEach(points => {
                // Convert raw [x,y] to Vector3
                const vectors = points.map(p => new THREE.Vector3(p[0], p[1], 0));
                
                // Create a smooth curve from the points
                // curveType: 'centripetal' helps avoid loops and overshooting
                // tension: 0.5 is default, higher values (up to 1) make it more linear/tight
                const curve = new THREE.CatmullRomCurve3(vectors, false, 'centripetal', 0.75);
                
                // Use getSpacedPoints for uniform distribution along the curve
                // Increased count for smoother look
                const POINTS_COUNT = 400;
                const sampledPoints = curve.getSpacedPoints(POINTS_COUNT); 
                const geometry = new THREE.BufferGeometry().setFromPoints(sampledPoints);
                
                // Start invisible
                geometry.setDrawRange(0, 0);

                const material = new THREE.LineBasicMaterial({ 
                    color: LINE_COLOR,
                    linewidth: LINE_WIDTH
                });

                const line = new THREE.Line(geometry, material);
                scene.add(line);

                const length = curve.getLength();
                
                currentStrokes.push({
                    line: line,
                    totalPoints: POINTS_COUNT,
                    curve: curve,
                    length: length,
                    startDistance: totalCharLength
                });

                totalCharLength += length;
            });

            // Start Animation
            startTime = performance.now();
            isAnimating = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isAnimating && currentStrokes.length > 0) {
                const now = performance.now();
                const elapsed = now - startTime;
                const distanceCovered = elapsed * DRAW_SPEED;
                
                let allDone = true;

                currentStrokes.forEach(stroke => {
                    const strokeEndDistance = stroke.startDistance + stroke.length;

                    if (distanceCovered >= strokeEndDistance) {
                        // Stroke fully drawn
                        stroke.line.geometry.setDrawRange(0, stroke.totalPoints + 1);
                    } else if (distanceCovered >= stroke.startDistance) {
                        // Stroke partially drawn
                        const strokeProgress = (distanceCovered - stroke.startDistance) / stroke.length;
                        const drawCount = Math.floor(strokeProgress * stroke.totalPoints);
                        stroke.line.geometry.setDrawRange(0, drawCount);
                        allDone = false;
                    } else {
                        // Stroke not started
                        stroke.line.geometry.setDrawRange(0, 0);
                        allDone = false;
                    }
                });

                if (allDone) {
                    isAnimating = false;
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>