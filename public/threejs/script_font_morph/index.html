<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Animate high-density point clouds that morph between script glyphs with interactive controls.">
    <title>Script Font Morph</title>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        #info {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            pointer-events: none;
            z-index: 100;
        }
        #controls {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 5px;
            pointer-events: auto;
            z-index: 100;
            width: 250px;
            display: flex; flex-direction: column; gap: 10px;
        }
        .control-row { display: flex; justify-content: space-between; align-items: center; }
        .control-row label { font-size: 0.9em; color: #aaa; }
        input[type=range] { width: 120px; }
        input[type=number] { width: 60px; background: #222; border: 1px solid #444; color: white; padding: 2px; }
    </style>
</head>
<body>
    <div id="info">
        <select id="char-select" style="background: #333; color: white; border: 1px solid #555; padding: 5px; font-size: 1.2em; margin-top: 10px; pointer-events: auto;">
            <option value="א">א (Aleph)</option>
            <option value="ב">ב (Bet)</option>
            <option value="ג">ג (Gimel)</option>
            <option value="ד">ד (Dalet)</option>
            <option value="ה">ה (He)</option>
            <option value="ו">ו (Vav)</option>
            <option value="ז">ז (Zayin)</option>
            <option value="ח">ח (Het)</option>
            <option value="ט">ט (Tet)</option>
            <option value="י">י (Yod)</option>
            <option value="כ">כ (Kaf)</option>
            <option value="ל">ל (Lamed)</option>
            <option value="מ">מ (Mem)</option>
            <option value="נ">נ (Nun)</option>
            <option value="ס">ס (Samekh)</option>
            <option value="ע">ע (Ayin)</option>
            <option value="פ">פ (Pe)</option>
            <option value="צ">צ (Tsade)</option>
            <option value="ק">ק (Qof)</option>
            <option value="ר">ר (Resh)</option>
            <option value="ש">ש (Shin)</option>
            <option value="ת">ת (Tav)</option>
            <option value="שלום">שלום</option>
            <option value="אהבה">אהבה</option>
            <option value="חיים">חיים</option>
        </select>
    </div>

    <div id="controls">
        <div class="control-row">
            <label>Points</label>
            <input type="range" id="points-range" min="1000" max="50000" step="1000" value="15000">
            <span id="points-val">15k</span>
        </div>
        <div class="control-row">
            <label>Duration (ms)</label>
            <input type="range" id="duration-range" min="200" max="3000" step="100" value="1200">
            <span id="duration-val">1200</span>
        </div>
        <div class="control-row">
            <label>Scatter Radius</label>
            <input type="range" id="radius-range" min="10" max="300" step="10" value="120">
            <span id="radius-val">120</span>
        </div>
        <hr style="width: 100%; border-color: #444;">
        <div class="control-row">
            <label>Gravity</label>
            <input type="range" id="gravity-range" min="0" max="2" step="0.1" value="0">
        </div>
        <div class="control-row">
            <label>Swirl Noise</label>
            <input type="range" id="wind-range" min="0" max="5" step="0.1" value="1">
        </div>
        <div class="control-row">
            <label>Swirl Strength</label>
            <input type="range" id="noise-range" min="0" max="5" step="0.1" value="1">
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "three/addons/libs/opentype.module.js": "https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.module.js"
            }
        }
    </script>
    <!-- Opentype.js is loaded via importmap -->

    <script type="module">
        import * as THREE from 'three';
        import { TTFLoader } from 'three/addons/loaders/TTFLoader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, particles;
        let geometry;
        const fontConfigs = [
            { id: 'scriptPrimary', url: 'assets/FrankRuehl.ttf' },
            { id: 'blockPrimary', url: 'assets/GveretLevin.ttf' },
            { id: 'scriptItalic', url: 'assets/DorianCLMBookItalic.ttf' },
            { id: 'blockSans', url: 'assets/Heebo.ttf' }
        ];

        const loadedFonts = [];
        let currentFontIndex = 0;
        let nextFontIndex = 1;
        let PARTICLE_COUNT = 15000;
        let cycleDuration = 1200;
        let scatterRadius = 120;
        let currentChar = 'א'; // Aleph
        const FONT_SIZE = 100;

        init();

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 300;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.minAzimuthAngle = -Math.PI / 3;
            controls.maxAzimuthAngle = Math.PI / 3;
            controls.minPolarAngle = Math.PI / 3;
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.enablePan = false;

            // UI Listeners
            const select = document.getElementById('char-select');
            select.addEventListener('change', (e) => {
                currentChar = e.target.value;
                updateCharacter();
            });

            const rebuildParticles = () => {
                if (particles) {
                    scene.remove(particles);
                }
                createParticles();
            };

            document.getElementById('points-range').addEventListener('input', (e) => {
                PARTICLE_COUNT = parseInt(e.target.value);
                document.getElementById('points-val').innerText = (PARTICLE_COUNT / 1000).toFixed(0) + 'k';
                if (loadedFonts.length >= 2) {
                    rebuildParticles();
                }
            });

            document.getElementById('duration-range').addEventListener('input', (e) => {
                cycleDuration = parseInt(e.target.value);
                document.getElementById('duration-val').innerText = cycleDuration;
            });

            document.getElementById('radius-range').addEventListener('input', (e) => {
                scatterRadius = parseInt(e.target.value);
                document.getElementById('radius-val').innerText = scatterRadius;
                if (loadedFonts.length >= 2) {
                    rebuildParticles();
                }
            });

            const updateUniform = (id, uniformName) => {
                document.getElementById(id).addEventListener('input', (e) => {
                    if (particles) {
                        particles.material.uniforms[uniformName].value = parseFloat(e.target.value);
                    }
                });
            };

            updateUniform('gravity-range', 'uGravity');
            updateUniform('wind-range', 'uNoiseDetune');
            updateUniform('noise-range', 'uNoiseStrength');

            // Load Fonts
            const loader = new TTFLoader();
            const fontLoader = new FontLoader();

            const loadFont = (url) => new Promise((resolve, reject) => {
                loader.load(url, (json) => {
                    try {
                        const font = fontLoader.parse(json);
                        resolve(font);
                    } catch (e) { reject(e); }
                }, undefined, reject);
            });

            try {
                const fonts = await Promise.all(fontConfigs.map(cfg => loadFont(cfg.url)));
                fonts.forEach((font, index) => loadedFonts[index] = font);

                if (loadedFonts.length < 2) {
                    throw new Error('At least two fonts are required for morphing.');
                }

                currentFontIndex = 0;
                nextFontIndex = 1 % loadedFonts.length;

                createParticles();
                animate();
                startMorphCycle();

            } catch (err) {
                console.error('Error loading fonts:', err);
            }

            window.addEventListener('resize', onWindowResize);
        }

        function getPointsFromFont(font, text, pointCount = PARTICLE_COUNT) {
            const shapes = font.generateShapes(text, FONT_SIZE);
            const geometry = new THREE.ShapeGeometry(shapes);
            geometry.computeBoundingBox();
            
            // Center the geometry
            const xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );
            const yMid = - 0.5 * ( geometry.boundingBox.max.y - geometry.boundingBox.min.y );
            geometry.translate( xMid, yMid, 0 );

            const rtlRegex = /[\u0590-\u05FF]/;
            if (rtlRegex.test(text)) {
                geometry.scale(-1, 1, 1);
            }

            // Sample points from the surface (triangles)
            const posAttribute = geometry.attributes.position;
            const indexAttribute = geometry.index; // ShapeGeometry usually has an index
            
            // Calculate total area
            let totalArea = 0;
            const triangleAreas = [];
            const triangleIndices = [];

            // Helper to get vertex
            const getVertex = (i) => {
                return new THREE.Vector3(
                    posAttribute.getX(i),
                    posAttribute.getY(i),
                    posAttribute.getZ(i)
                );
            };

            // If indexed
            if (indexAttribute) {
                for (let i = 0; i < indexAttribute.count; i += 3) {
                    const a = getVertex(indexAttribute.getX(i));
                    const b = getVertex(indexAttribute.getX(i+1));
                    const c = getVertex(indexAttribute.getX(i+2));
                    
                    const area = new THREE.Triangle(a, b, c).getArea();
                    totalArea += area;
                    triangleAreas.push(area);
                    triangleIndices.push([a, b, c]);
                }
            } else {
                // Non-indexed
                for (let i = 0; i < posAttribute.count; i += 3) {
                    const a = getVertex(i);
                    const b = getVertex(i+1);
                    const c = getVertex(i+2);
                    
                    const area = new THREE.Triangle(a, b, c).getArea();
                    totalArea += area;
                    triangleAreas.push(area);
                    triangleIndices.push([a, b, c]);
                }
            }

            // Sample points
            const points = [];
            for (let i = 0; i < pointCount; i++) {
                // Select triangle by weighted random
                let r = Math.random() * totalArea;
                let triIndex = 0;
                for (let j = 0; j < triangleAreas.length; j++) {
                    r -= triangleAreas[j];
                    if (r <= 0) {
                        triIndex = j;
                        break;
                    }
                }

                // Random point in triangle
                const [a, b, c] = triangleIndices[triIndex];
                
                // Random barycentric coordinates
                let r1 = Math.random();
                let r2 = Math.random();
                if (r1 + r2 > 1) {
                    r1 = 1 - r1;
                    r2 = 1 - r2;
                }
                
                const p = new THREE.Vector3()
                    .copy(a)
                    .addScaledVector(new THREE.Vector3().subVectors(b, a), r1)
                    .addScaledVector(new THREE.Vector3().subVectors(c, a), r2);
                
                points.push(p.x, p.y, p.z);
            }

            return new Float32Array(points);
        }

        function createParticles() {
            if (loadedFonts.length < 2) return;

            const pointsA = getPointsFromFont(loadedFonts[currentFontIndex], currentChar, PARTICLE_COUNT);
            const pointsB = getPointsFromFont(loadedFonts[nextFontIndex], currentChar, PARTICLE_COUNT);
            
            // Random scatter positions (homogeneous spherical fuzz)
            const pointsRandom = new Float32Array(PARTICLE_COUNT * 3);
            const goldenAngle = Math.PI * (3 - Math.sqrt(5));
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const t = i + 0.5;
                const y = 1 - (t / PARTICLE_COUNT) * 2; // even spacing in [-1,1]
                const radius = Math.sqrt(Math.max(0, 1 - y * y));
                const theta = goldenAngle * i;
                const dirX = Math.cos(theta) * radius;
                const dirZ = Math.sin(theta) * radius;
                const dirY = y;

                const jitter = 0.35 + 0.65 * Math.random();
                const radial = scatterRadius * jitter * Math.cbrt(Math.random());

                pointsRandom[i*3] = dirX * radial;
                pointsRandom[i*3+1] = dirY * radial;
                pointsRandom[i*3+2] = dirZ * radial;
            }

            geometry = new THREE.BufferGeometry();
            
            // We'll use a shader material, so we pass attributes
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pointsA), 3));
            geometry.setAttribute('targetA', new THREE.BufferAttribute(pointsA, 3));
            geometry.setAttribute('targetB', new THREE.BufferAttribute(pointsB, 3));
            geometry.setAttribute('scatterPos', new THREE.BufferAttribute(pointsRandom, 3));
            
            // Add random offset for noise animation
            const randoms = new Float32Array(PARTICLE_COUNT);
            for(let i=0; i<PARTICLE_COUNT; i++) randoms[i] = Math.random();
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uMorph: { value: 0 }, // 0 = A, 1 = B
                    uScatter: { value: 0 }, // 0 = Formed, 1 = Scattered
                    uGravity: { value: parseFloat(document.getElementById('gravity-range').value) },
                    uNoiseDetune: { value: parseFloat(document.getElementById('wind-range').value) },
                    uNoiseStrength: { value: parseFloat(document.getElementById('noise-range').value) },
                    uColorA: { value: new THREE.Color(0x4db8ff) },
                    uColorB: { value: new THREE.Color(0xff4d4d) }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uMorph;
                    uniform float uScatter;
                    uniform float uGravity;
                    uniform float uNoiseDetune;
                    uniform float uNoiseStrength;
                    
                    attribute vec3 targetA;
                    attribute vec3 targetB;
                    attribute vec3 scatterPos;
                    attribute float aRandom;
                    
                    varying float vAlpha;
                    varying vec3 vColor;

                    const float PI = 3.141592653589793;
                    const float TWO_PI = PI * 2.0;
                    
                    // Simplex noise or simple sine noise
                    vec3 getNoise(vec3 p, float t) {
                        return vec3(
                            sin(p.y * 0.1 + t + aRandom * 6.0),
                            cos(p.x * 0.1 + t + aRandom * 6.0),
                            sin(p.z * 0.1 + t)
                        );
                    }

                    float hash(float v) {
                        return fract(sin(v * 43758.5453) * 43758.5453);
                    }

                    mat2 rot2(float a) {
                        float s = sin(a);
                        float c = cos(a);
                        return mat2(c, -s, s, c);
                    }

                    vec3 swirlField(vec3 pos, float time, float noiseDetune, float strength, float scatterMix) {
                        float radialXY = max(length(pos.xy), 0.0001);
                        float radialYZ = max(length(vec2(pos.y, pos.z)), 0.0001);
                        float radialNormXY = clamp(radialXY / 150.0, 0.0, 1.0);
                        float radialNormYZ = clamp(radialYZ / 150.0, 0.0, 1.0);
                        float jitter = hash(aRandom * 91.32) * 0.6 + 0.4;

                        // Swirl around Z axis (affecting XY plane)
                        float baseAngleXY = atan(pos.y, pos.x);
                        float spiralTurnsXY = radialNormXY * (TWO_PI * 2.0);
                        float swirlAngleXY = baseAngleXY + spiralTurnsXY + time * (0.8 + 0.2 * strength);
                        swirlAngleXY += strength * 0.35 * sin(time * 0.6 + radialXY * 0.2 + aRandom * 5.0);
                        vec2 rotatedXY = rot2(swirlAngleXY) * pos.xy;

                        // Swirl around X axis (affecting YZ plane)
                        float baseAngleYZ = atan(pos.z, pos.y);
                        float spiralTurnsYZ = radialNormYZ * (TWO_PI * 1.5);
                        float swirlAngleYZ = baseAngleYZ + spiralTurnsYZ + time * (0.7 + 0.3 * strength);
                        swirlAngleYZ += strength * 0.3 * cos(time * 0.5 + radialYZ * 0.25 + aRandom * 4.0);
                        vec2 rotatedYZ = rot2(swirlAngleYZ) * vec2(pos.y, pos.z);

                        vec2 tangentXY = radialXY < 0.001 ? vec2(0.0, 1.0) : normalize(vec2(-rotatedXY.y, rotatedXY.x));
                        float spiralXY = 0.7 + 0.3 * sin(radialXY * 0.35 + time * 1.2 + aRandom * 3.0);
                        vec2 swirlXY = rotatedXY * (0.8 + 0.2 * strength) + tangentXY * radialXY * spiralXY * strength * jitter * 0.5;

                        float lift = sin(time * 1.3 + radialXY * 0.18 + aRandom * 4.5) * strength * 20.0;
                        float drift = cos(time * 0.7 + pos.x * 0.05 + aRandom * 2.5) * strength * 10.0;

                        vec3 swirlPos = vec3(
                            swirlXY.x,
                            mix(swirlXY.y, rotatedYZ.x, 0.55),
                            rotatedYZ.y + lift + drift
                        );

                        float coherence = 1.0 - 0.6 * clamp(strength - 0.4, 0.0, 1.0);
                        float noiseGain = mix(1.0, 12.0, clamp(noiseDetune / 5.0, 0.0, 1.0)) * (0.6 + 0.4 * (1.0 - scatterMix));
                        float curlAmp = (4.0 + strength * 10.0) * (0.8 + 0.2 * noiseDetune);
                        vec3 curl = getNoise(swirlPos * (0.2 + noiseDetune * 0.05) + pos * 0.15, time * 0.9) * curlAmp * noiseGain * coherence;
                        return swirlPos + curl;
                    }

                    void main() {
                        // 1. Morph between A and B
                        vec3 formedPos = mix(targetA, targetB, uMorph);
                        
                        float swirlStrength = max(0.05, uNoiseStrength);
                        float noiseAmp = swirlStrength * (6.0 + uNoiseDetune * 2.0);

                        // 2. Add some subtle motion to formed state
                        formedPos += getNoise(formedPos, uTime * 1.5) * noiseAmp * 0.08;

                        float scatterMix = smoothstep(0.0, 1.0, uScatter);

                        // 3. Calculate Scatter Position with coherent dual-axis swirl field
                        vec3 swirlScatter = swirlField(scatterPos, uTime, uNoiseDetune, swirlStrength, scatterMix);
                        vec3 gravityOffset = vec3(0.0, -uGravity * 60.0, 0.0) * scatterMix;
                        vec3 noisyScatter = swirlScatter + gravityOffset;
                        
                        // 4. Mix Formed and Scatter
                        vec3 finalPos = mix(formedPos, noisyScatter, scatterMix);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // Size attenuation
                        gl_PointSize = (3.0 + aRandom * 2.0) * (300.0 / -mvPosition.z);
                        
                        // Fade out when scattered
                        vAlpha = 1.0 - scatterMix * 0.35;
                        
                        // Color mix
                        vec3 colorA = vec3(0.3, 0.7, 1.0); // Blueish
                        vec3 colorB = vec3(1.0, 0.8, 0.2); // Goldish
                        vColor = mix(colorA, colorB, uMorph);
                    }
                `,
                fragmentShader: `
                    varying float vAlpha;
                    varying vec3 vColor;
                    
                    void main() {
                        // Circular particle
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        if(length(coord) > 0.5) discard;
                        
                        gl_FragColor = vec4(vColor, vAlpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function updateCharacter() {
            if (!geometry || loadedFonts.length < 2) return;

            const pointCount = geometry.attributes.targetA.count;
            const pointsA = getPointsFromFont(loadedFonts[currentFontIndex], currentChar, pointCount);
            const pointsB = getPointsFromFont(loadedFonts[nextFontIndex], currentChar, pointCount);

            geometry.attributes.targetA.array.set(pointsA);
            geometry.attributes.targetB.array.set(pointsB);
            geometry.attributes.position.array.set(pointsA);
            
            geometry.attributes.targetA.needsUpdate = true;
            geometry.attributes.targetB.needsUpdate = true;
            geometry.attributes.position.needsUpdate = true;
        }

        function startMorphCycle() {
            const pause = 800; // Reduced from 1000
            
            const animateProp = (obj, prop, target, time) => {
                return new Promise(resolve => {
                    const start = obj[prop];
                    const startTime = performance.now();
                    
                    const update = () => {
                        const now = performance.now();
                        const progress = Math.min((now - startTime) / time, 1);
                        // Ease in out
                        const ease = progress < .5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;
                        
                        obj[prop] = start + (target - start) * ease;
                        
                        if (progress < 1) {
                            requestAnimationFrame(update);
                        } else {
                            resolve();
                        }
                    };
                    update();
                });
            };

            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            const advanceFonts = () => {
                if (loadedFonts.length < 2 || !geometry) return;

                const targetBArray = geometry.attributes.targetB.array;
                geometry.attributes.targetA.array.set(targetBArray);
                geometry.attributes.targetA.needsUpdate = true;
                geometry.attributes.position.array.set(targetBArray);
                geometry.attributes.position.needsUpdate = true;

                currentFontIndex = nextFontIndex;
                nextFontIndex = (nextFontIndex + 1) % loadedFonts.length;

                const pointCount = geometry.attributes.targetA.count;
                const nextPoints = getPointsFromFont(loadedFonts[nextFontIndex], currentChar, pointCount);
                geometry.attributes.targetB.array.set(nextPoints);
                geometry.attributes.targetB.needsUpdate = true;

                particles.material.uniforms.uMorph.value = 0;
            };

            const cycle = async () => {
                await sleep(pause);

                await animateProp(particles.material.uniforms.uScatter, 'value', 1, cycleDuration);
                particles.material.uniforms.uMorph.value = 1;
                await animateProp(particles.material.uniforms.uScatter, 'value', 0, cycleDuration);

                await sleep(pause);

                advanceFonts();
                
                cycle();
            };
            
            cycle();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (particles) {
                particles.material.uniforms.uTime.value = performance.now() * 0.001;
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
