<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Animate high-density point clouds that morph between script glyphs with interactive controls.">
    <title>Script Font Morph</title>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        #info {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            pointer-events: none;
            z-index: 100;
        }
        #controls {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 5px;
            pointer-events: auto;
            z-index: 100;
            width: 250px;
            display: flex; flex-direction: column; gap: 10px;
        }
        .control-row { display: flex; justify-content: space-between; align-items: center; }
        .control-row label { font-size: 0.9em; color: #aaa; }
        input[type=range] { width: 120px; }
        input[type=number] { width: 60px; background: #222; border: 1px solid #444; color: white; padding: 2px; }
    </style>
</head>
<body>
    <div id="info">
        <select id="char-select" style="background: #333; color: white; border: 1px solid #555; padding: 5px; font-size: 1.2em; margin-top: 10px; pointer-events: auto;">
            <option value="א">א (Aleph)</option>
            <option value="ב">ב (Bet)</option>
            <option value="ג">ג (Gimel)</option>
            <option value="ד">ד (Dalet)</option>
            <option value="ה">ה (He)</option>
            <option value="ו">ו (Vav)</option>
            <option value="ז">ז (Zayin)</option>
            <option value="ח">ח (Het)</option>
            <option value="ט">ט (Tet)</option>
            <option value="י">י (Yod)</option>
            <option value="כ">כ (Kaf)</option>
            <option value="ל">ל (Lamed)</option>
            <option value="מ">מ (Mem)</option>
            <option value="נ">נ (Nun)</option>
            <option value="ס">ס (Samekh)</option>
            <option value="ע">ע (Ayin)</option>
            <option value="פ">פ (Pe)</option>
            <option value="צ">צ (Tsade)</option>
            <option value="ק">ק (Qof)</option>
            <option value="ר">ר (Resh)</option>
            <option value="ש">ש (Shin)</option>
            <option value="ת">ת (Tav)</option>
        </select>
    </div>

    <div id="controls">
        <div class="control-row">
            <label>Points</label>
            <input type="range" id="points-range" min="1000" max="50000" step="1000" value="15000">
            <span id="points-val">15k</span>
        </div>
        <div class="control-row">
            <label>Duration (ms)</label>
            <input type="range" id="duration-range" min="200" max="3000" step="100" value="1200">
            <span id="duration-val">1200</span>
        </div>
        <div class="control-row">
            <label>Scatter Radius</label>
            <input type="range" id="radius-range" min="10" max="300" step="10" value="120">
            <span id="radius-val">120</span>
        </div>
        <hr style="width: 100%; border-color: #444;">
        <div class="control-row">
            <label>Gravity</label>
            <input type="range" id="gravity-range" min="0" max="2" step="0.1" value="0">
        </div>
        <div class="control-row">
            <label>Swirl Speed</label>
            <input type="range" id="wind-range" min="-2" max="2" step="0.1" value="0">
        </div>
        <div class="control-row">
            <label>Swirl Strength</label>
            <input type="range" id="noise-range" min="0" max="5" step="0.1" value="1">
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "three/addons/libs/opentype.module.js": "https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.module.js"
            }
        }
    </script>
    <!-- Opentype.js is loaded via importmap -->

    <script type="module">
        import * as THREE from 'three';
        import { TTFLoader } from 'three/addons/loaders/TTFLoader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, particles;
        let geometry;
        const fontConfigs = [
            { id: 'scriptPrimary', url: 'assets/FrankRuehl.ttf' },
            { id: 'blockPrimary', url: 'assets/GveretLevin.ttf' },
            { id: 'scriptItalic', url: 'assets/DorianCLMBookItalic.ttf' },
            { id: 'blockSans', url: 'assets/Heebo.ttf' }
        ];

        const loadedFonts = [];
        let currentFontIndex = 0;
        let nextFontIndex = 1;
        let PARTICLE_COUNT = 15000;
        let cycleDuration = 1200;
        let scatterRadius = 120;
        let currentChar = 'א'; // Aleph
        const FONT_SIZE = 100;

        init();

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 300;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // UI Listeners
            const select = document.getElementById('char-select');
            select.addEventListener('change', (e) => {
                currentChar = e.target.value;
                updateCharacter();
            });

            const rebuildParticles = () => {
                if (particles) {
                    scene.remove(particles);
                }
                createParticles();
            };

            document.getElementById('points-range').addEventListener('input', (e) => {
                PARTICLE_COUNT = parseInt(e.target.value);
                document.getElementById('points-val').innerText = (PARTICLE_COUNT / 1000).toFixed(0) + 'k';
                if (loadedFonts.length >= 2) {
                    rebuildParticles();
                }
            });

            document.getElementById('duration-range').addEventListener('input', (e) => {
                cycleDuration = parseInt(e.target.value);
                document.getElementById('duration-val').innerText = cycleDuration;
            });

            document.getElementById('radius-range').addEventListener('input', (e) => {
                scatterRadius = parseInt(e.target.value);
                document.getElementById('radius-val').innerText = scatterRadius;
                if (loadedFonts.length >= 2) {
                    rebuildParticles();
                }
            });

            const updateUniform = (id, uniformName) => {
                document.getElementById(id).addEventListener('input', (e) => {
                    if (particles) {
                        particles.material.uniforms[uniformName].value = parseFloat(e.target.value);
                    }
                });
            };

            updateUniform('gravity-range', 'uGravity');
            updateUniform('wind-range', 'uWind');
            updateUniform('noise-range', 'uNoiseStrength');

            // Load Fonts
            const loader = new TTFLoader();
            const fontLoader = new FontLoader();

            const loadFont = (url) => new Promise((resolve, reject) => {
                loader.load(url, (json) => {
                    try {
                        const font = fontLoader.parse(json);
                        resolve(font);
                    } catch (e) { reject(e); }
                }, undefined, reject);
            });

            try {
                const fonts = await Promise.all(fontConfigs.map(cfg => loadFont(cfg.url)));
                fonts.forEach((font, index) => loadedFonts[index] = font);

                if (loadedFonts.length < 2) {
                    throw new Error('At least two fonts are required for morphing.');
                }

                currentFontIndex = 0;
                nextFontIndex = 1 % loadedFonts.length;

                createParticles();
                animate();
                startMorphCycle();

            } catch (err) {
                console.error('Error loading fonts:', err);
            }

            window.addEventListener('resize', onWindowResize);
        }

        function getPointsFromFont(font, char, pointCount = PARTICLE_COUNT) {
            const shapes = font.generateShapes(char, FONT_SIZE);
            const geometry = new THREE.ShapeGeometry(shapes);
            geometry.computeBoundingBox();
            
            // Center the geometry
            const xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );
            const yMid = - 0.5 * ( geometry.boundingBox.max.y - geometry.boundingBox.min.y );
            geometry.translate( xMid, yMid, 0 );

            // Sample points from the surface (triangles)
            const posAttribute = geometry.attributes.position;
            const indexAttribute = geometry.index; // ShapeGeometry usually has an index
            
            // Calculate total area
            let totalArea = 0;
            const triangleAreas = [];
            const triangleIndices = [];

            // Helper to get vertex
            const getVertex = (i) => {
                return new THREE.Vector3(
                    posAttribute.getX(i),
                    posAttribute.getY(i),
                    posAttribute.getZ(i)
                );
            };

            // If indexed
            if (indexAttribute) {
                for (let i = 0; i < indexAttribute.count; i += 3) {
                    const a = getVertex(indexAttribute.getX(i));
                    const b = getVertex(indexAttribute.getX(i+1));
                    const c = getVertex(indexAttribute.getX(i+2));
                    
                    const area = new THREE.Triangle(a, b, c).getArea();
                    totalArea += area;
                    triangleAreas.push(area);
                    triangleIndices.push([a, b, c]);
                }
            } else {
                // Non-indexed
                for (let i = 0; i < posAttribute.count; i += 3) {
                    const a = getVertex(i);
                    const b = getVertex(i+1);
                    const c = getVertex(i+2);
                    
                    const area = new THREE.Triangle(a, b, c).getArea();
                    totalArea += area;
                    triangleAreas.push(area);
                    triangleIndices.push([a, b, c]);
                }
            }

            // Sample points
            const points = [];
            for (let i = 0; i < pointCount; i++) {
                // Select triangle by weighted random
                let r = Math.random() * totalArea;
                let triIndex = 0;
                for (let j = 0; j < triangleAreas.length; j++) {
                    r -= triangleAreas[j];
                    if (r <= 0) {
                        triIndex = j;
                        break;
                    }
                }

                // Random point in triangle
                const [a, b, c] = triangleIndices[triIndex];
                
                // Random barycentric coordinates
                let r1 = Math.random();
                let r2 = Math.random();
                if (r1 + r2 > 1) {
                    r1 = 1 - r1;
                    r2 = 1 - r2;
                }
                
                const p = new THREE.Vector3()
                    .copy(a)
                    .addScaledVector(new THREE.Vector3().subVectors(b, a), r1)
                    .addScaledVector(new THREE.Vector3().subVectors(c, a), r2);
                
                points.push(p.x, p.y, p.z);
            }

            return new Float32Array(points);
        }

        function createParticles() {
            if (loadedFonts.length < 2) return;

            const pointsA = getPointsFromFont(loadedFonts[currentFontIndex], currentChar, PARTICLE_COUNT);
            const pointsB = getPointsFromFont(loadedFonts[nextFontIndex], currentChar, PARTICLE_COUNT);
            
            // Random scatter positions (Spherical Fuzz)
            const pointsRandom = new Float32Array(PARTICLE_COUNT * 3);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                // Random point in sphere
                const r = scatterRadius * Math.cbrt(Math.random()); 
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                
                pointsRandom[i*3] = x;
                pointsRandom[i*3+1] = y;
                pointsRandom[i*3+2] = z;
            }

            geometry = new THREE.BufferGeometry();
            
            // We'll use a shader material, so we pass attributes
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pointsA), 3));
            geometry.setAttribute('targetA', new THREE.BufferAttribute(pointsA, 3));
            geometry.setAttribute('targetB', new THREE.BufferAttribute(pointsB, 3));
            geometry.setAttribute('scatterPos', new THREE.BufferAttribute(pointsRandom, 3));
            
            // Add random offset for noise animation
            const randoms = new Float32Array(PARTICLE_COUNT);
            for(let i=0; i<PARTICLE_COUNT; i++) randoms[i] = Math.random();
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uMorph: { value: 0 }, // 0 = A, 1 = B
                    uScatter: { value: 0 }, // 0 = Formed, 1 = Scattered
                    uGravity: { value: parseFloat(document.getElementById('gravity-range').value) },
                    uWind: { value: parseFloat(document.getElementById('wind-range').value) },
                    uNoiseStrength: { value: parseFloat(document.getElementById('noise-range').value) },
                    uColorA: { value: new THREE.Color(0x4db8ff) },
                    uColorB: { value: new THREE.Color(0xff4d4d) }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uMorph;
                    uniform float uScatter;
                    uniform float uGravity;
                    uniform float uWind;
                    uniform float uNoiseStrength;
                    
                    attribute vec3 targetA;
                    attribute vec3 targetB;
                    attribute vec3 scatterPos;
                    attribute float aRandom;
                    
                    varying float vAlpha;
                    varying vec3 vColor;
                    
                    // Simplex noise or simple sine noise
                    vec3 getNoise(vec3 p, float t) {
                        return vec3(
                            sin(p.y * 0.1 + t + aRandom * 6.0),
                            cos(p.x * 0.1 + t + aRandom * 6.0),
                            sin(p.z * 0.1 + t)
                        );
                    }

                    // Swirl function for vortex effect
                    vec3 swirl(vec3 pos, float time, float strength) {
                        float angle = atan(pos.y, pos.x) + time * strength + aRandom * 3.14;
                        float radius = length(pos.xy);
                        return vec3(cos(angle) * radius, sin(angle) * radius, pos.z + sin(time + aRandom * 6.28) * 10.0);
                    }

                    void main() {
                        // 1. Morph between A and B
                        vec3 formedPos = mix(targetA, targetB, uMorph);
                        
                        // 2. Add some subtle motion to formed state
                        formedPos += getNoise(formedPos, uTime * 2.0) * uNoiseStrength;

                        // 3. Calculate Scatter Position with swirl
                        vec3 swirledScatter = swirl(scatterPos, uTime * uWind, uNoiseStrength * 0.5);
                        vec3 noisyScatter = swirledScatter + getNoise(swirledScatter, uTime * 0.5) * 20.0;
                        
                        // Apply gravity pull towards center or down
                        vec3 gravityOffset = vec3(0.0, -uGravity * 50.0, 0.0) * uScatter;
                        noisyScatter += gravityOffset;
                        
                        // 4. Mix Formed and Scatter
                        vec3 finalPos = mix(formedPos, noisyScatter, uScatter);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // Size attenuation
                        gl_PointSize = (3.0 + aRandom * 2.0) * (300.0 / -mvPosition.z);
                        
                        // Fade out when scattered?
                        vAlpha = 1.0 - uScatter * 0.3;
                        
                        // Color mix
                        vec3 colorA = vec3(0.3, 0.7, 1.0); // Blueish
                        vec3 colorB = vec3(1.0, 0.8, 0.2); // Goldish
                        vColor = mix(colorA, colorB, uMorph);
                    }
                `,
                fragmentShader: `
                    varying float vAlpha;
                    varying vec3 vColor;
                    
                    void main() {
                        // Circular particle
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        if(length(coord) > 0.5) discard;
                        
                        gl_FragColor = vec4(vColor, vAlpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function updateCharacter() {
            if (!geometry || loadedFonts.length < 2) return;

            const pointCount = geometry.attributes.targetA.count;
            const pointsA = getPointsFromFont(loadedFonts[currentFontIndex], currentChar, pointCount);
            const pointsB = getPointsFromFont(loadedFonts[nextFontIndex], currentChar, pointCount);

            geometry.attributes.targetA.array.set(pointsA);
            geometry.attributes.targetB.array.set(pointsB);
            geometry.attributes.position.array.set(pointsA);
            
            geometry.attributes.targetA.needsUpdate = true;
            geometry.attributes.targetB.needsUpdate = true;
            geometry.attributes.position.needsUpdate = true;
        }

        function startMorphCycle() {
            const pause = 800; // Reduced from 1000
            
            const animateProp = (obj, prop, target, time) => {
                return new Promise(resolve => {
                    const start = obj[prop];
                    const startTime = performance.now();
                    
                    const update = () => {
                        const now = performance.now();
                        const progress = Math.min((now - startTime) / time, 1);
                        // Ease in out
                        const ease = progress < .5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;
                        
                        obj[prop] = start + (target - start) * ease;
                        
                        if (progress < 1) {
                            requestAnimationFrame(update);
                        } else {
                            resolve();
                        }
                    };
                    update();
                });
            };

            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            const advanceFonts = () => {
                if (loadedFonts.length < 2 || !geometry) return;

                const targetBArray = geometry.attributes.targetB.array;
                geometry.attributes.targetA.array.set(targetBArray);
                geometry.attributes.targetA.needsUpdate = true;
                geometry.attributes.position.array.set(targetBArray);
                geometry.attributes.position.needsUpdate = true;

                currentFontIndex = nextFontIndex;
                nextFontIndex = (nextFontIndex + 1) % loadedFonts.length;

                const pointCount = geometry.attributes.targetA.count;
                const nextPoints = getPointsFromFont(loadedFonts[nextFontIndex], currentChar, pointCount);
                geometry.attributes.targetB.array.set(nextPoints);
                geometry.attributes.targetB.needsUpdate = true;

                particles.material.uniforms.uMorph.value = 0;
            };

            const cycle = async () => {
                await sleep(pause);

                await animateProp(particles.material.uniforms.uScatter, 'value', 1, cycleDuration);
                particles.material.uniforms.uMorph.value = 1;
                await animateProp(particles.material.uniforms.uScatter, 'value', 0, cycleDuration);

                await sleep(pause);

                advanceFonts();
                
                cycle();
            };
            
            cycle();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (particles) {
                particles.material.uniforms.uTime.value = performance.now() * 0.001;
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
