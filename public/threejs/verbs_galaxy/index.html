<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Explore 350+ verb roots in a 3D galaxy with search, audio pronunciations, and conjugation panels.">
    <title>Verbs Galaxy - Roots Edition</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #050510; color: white; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent browser zoom/scroll */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
        }
        #canvas-container { width: 100vw; height: 100vh; touch-action: none; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
            justify-content: flex-end; /* Align to bottom */
            z-index: 1000;
        }

        /* Controls Panel (Footer) */
        #controls-panel {
            width: 100%;
            background: rgba(10, 10, 15, 0.95);
            border-top: 1px solid #333;
            padding: 15px 20px;
            display: flex; align-items: center; justify-content: center; gap: 30px;
            pointer-events: auto;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            box-sizing: border-box;
            touch-action: manipulation; /* Allow interaction */
        }

        .control-group { display: flex; flex-direction: column; gap: 5px; }
        .control-label { font-size: 0.7em; color: #666; text-transform: uppercase; letter-spacing: 1px; }
        
        select {
            background: #111; color: #fff; border: 1px solid #333;
            padding: 6px 10px; border-radius: 4px; font-size: 0.9em;
            outline: none; cursor: pointer; min-width: 100px;
            touch-action: manipulation;
        }
        select:hover { border-color: #4db8ff; }

        /* Search in Footer */
        #search-box {
            background: rgba(255,255,255,0.1); border: 1px solid #333; color: white;
            padding: 8px 12px; border-radius: 20px; width: 250px;
            font-size: 0.9em; outline: none; transition: all 0.2s;
            touch-action: manipulation;
        }
        #search-box:focus { border-color: #4db8ff; background: rgba(255,255,255,0.15); }

        /* 3D Labels */
        .root-label {
            font-size: 24px; font-weight: bold; color: var(--root-color, #4db8ff);
            text-shadow: 0 0 10px rgba(77, 184, 255, 0.5);
            cursor: pointer; pointer-events: auto;
            transition: all 0.3s;
            user-select: none;
        }
        .root-label:hover { color: #fff; transform: scale(1.2); }
        .root-label.active { color: #fff; text-shadow: 0 0 20px #4db8ff; font-size: 32px; }

        .verb-label {
            font-size: 16px; color: #aaa;
            background: rgba(0,0,0,0.85);
            padding: 6px 10px; border-radius: 8px;
            border: 1px solid #333;
            cursor: pointer; pointer-events: auto;
            transition: all 0.2s;
            white-space: nowrap;
            text-align: center;
            display: flex; flex-direction: column; align-items: center; gap: 2px;
        }
        .verb-label:hover { 
            background: rgba(20, 20, 30, 0.95); 
            border-color: #4db8ff; color: white;
            z-index: 100;
        }
        .verb-sub { 
            font-size: 0.75em; color: #888; 
            display: flex; align-items: center; gap: 6px;
            margin-top: 2px;
        }
        
        .info-btn {
            background: none; border: none; padding: 0;
            font-size: 1.1em; cursor: pointer; opacity: 0.6;
            transition: opacity 0.2s;
        }
        .info-btn:hover { opacity: 1; transform: scale(1.1); }

        /* Info Panel (Right Side) */
        #info-panel {
            position: absolute; top: 80px; right: 20px; bottom: 100px;
            width: 350px;
            background: rgba(10, 10, 15, 0.95);
            border-left: 1px solid #333;
            padding: 20px;
            transform: translateX(110%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            overflow-y: auto;
            border-radius: 10px;
            touch-action: pan-y; /* Allow vertical scroll */
        }
        #info-panel.visible { transform: translateX(0); }

        #close-panel {
            position: absolute; top: 10px; right: 10px;
            background: none; border: none;
            color: #666; font-size: 24px; line-height: 1;
            cursor: pointer; padding: 5px;
            transition: color 0.2s;
            z-index: 10;
        }
        #close-panel:hover { color: #fff; }

        /* Satellite Layer (2D Overlay) */
        #satellite-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 500;
            overflow: hidden;
        }
        
        .satellite-item {
            position: absolute;
            pointer-events: auto;
            /* Default Mobile: Pinned to right */
            right: 10px;
            width: auto;
            max-width: 180px;
            transition: top 0.1s linear; /* Smooth vertical tracking */
        }

        @media (min-width: 800px) {
            .satellite-item {
                right: auto;
                /* Desktop: Pinned to right of center */
                left: calc(50% + 120px);
                max-width: 300px;
            }
        }

        h1 { margin: 0; font-size: 1.5em; background: linear-gradient(45deg, #4db8ff, #b84dff); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; }
        
        /* Search */
        #search-box {
            background: rgba(0,0,0,0.5); border: 1px solid #444; color: white;
            padding: 8px; border-radius: 5px; width: 200px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="satellite-layer"></div>

    <div id="ui-layer">
        <!-- Top Bar Removed -->

        <div id="controls-panel">
            <input type="text" id="search-box" placeholder="Search roots or verbs...">
            
            <div class="control-group">
                <span class="control-label">Tense</span>
                <select id="tense-select">
                    <option value="inf">Infinitive (执驻职注止)</option>
                    <option value="past">Past (注指址专)</option>
                    <option value="present">Present (止侄)</option>
                    <option value="future">Future (注指转执)</option>
                    <option value="imperative">Imperative (爪执旨旨)</option>
                </select>
            </div>
            <div class="control-group">
                <span class="control-label">Pronoun</span>
                <select id="pronoun-select" disabled>
                    <option value="any">--</option>
                    <option value="">I (植执)</option>
                    <option value="转">You m.s. (址转指旨)</option>
                    <option value="转">You f.s. (址转职旨)</option>
                    <option value="">He (旨)</option>
                    <option value="">She (执)</option>
                    <option value="">We (植址职旨)</option>
                    <option value="转">You m.pl. (址转侄旨)</option>
                    <option value="转">You f.pl. (址转侄旨)</option>
                    <option value="">They m. (值)</option>
                    <option value="">They f. (值)</option>
                </select>
            </div>
        </div>

        <div id="info-panel">
            <button id="close-panel">&times;</button>
            <div id="panel-content"></div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        // OrbitControls removed
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import TWEEN from 'three/addons/libs/tween.module.js';

        // --- State ---
        const state = {
            tense: 'inf',
            pronoun: '', // Default to 'I' for conjugations
            activeRoot: null,
            roots: {}, // Grouped data
            objects: {
                roots: [],
                satellites: []
            },
            // View State
            scrollY: 0,
            targetScrollY: 0,
            helixRotation: 0,
            targetHelixRotation: 0,
            isDragging: false,
            lastMouseY: 0,
            lastMouseX: 0
        };

        // --- Constants ---
        const HELIX_RADIUS = 30;
        const HELIX_HEIGHT_STEP = 8;
        const SATELLITE_RADIUS = 35; 
        const BUBBLE_RADIUS = 150; // Range of inflation
        const BUBBLE_STRENGTH = 2.5; // Multiplier for spacing in center

        // --- Three.js Globals ---
        let scene, camera, renderer, labelRenderer, raycaster, mouse;
        let rootGroup, satelliteGroup;

        init();

        async function init() {
            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.008);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 120); // Fixed Z distance

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.zIndex = '0';
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.zIndex = '1'; 
            labelRenderer.domElement.style.pointerEvents = 'none'; 
            document.getElementById('canvas-container').appendChild(labelRenderer.domElement);

            // Custom Controls (No OrbitControls)
            const canvas = document.getElementById('canvas-container');
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('wheel', onWheel);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevent long-press menu

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Groups
            rootGroup = new THREE.Group();
            satelliteGroup = new THREE.Group();
            scene.add(rootGroup);
            scene.add(satelliteGroup);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0x4db8ff, 1, 100);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
            document.getElementById('close-panel').addEventListener('click', () => {
                document.getElementById('info-panel').classList.remove('visible');
            });

            // Search Listener
            const searchBox = document.getElementById('search-box');
            searchBox.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    performSearch(searchBox.value);
                }
            });

            // 2. Load & Process Data
            try {
                const response = await fetch('verbs.json');
                const rawData = await response.json();
                processData(rawData);
                buildHelix();
                setupUI();
                animate();
            } catch (e) {
                console.error("Failed to load data", e);
            }

            window.addEventListener('resize', onWindowResize);
        }

        function processData(data) {
            // Group by Root
            for (const key in data) {
                const verb = data[key];
                const rootStr = verb.rt.join('.');
                if (!state.roots[rootStr]) {
                    state.roots[rootStr] = [];
                }
                // Add key to verb object for reference
                verb._key = key;
                state.roots[rootStr].push(verb);
            }
        }

        function getViridisColor(t) {
            t = Math.max(0, Math.min(1, t));
            const stops = [
                { t: 0.0, c: [68, 1, 84] },     // #440154
                { t: 0.25, c: [59, 82, 139] },  // #3b528b
                { t: 0.5, c: [33, 145, 140] },  // #21918c
                { t: 0.75, c: [94, 201, 98] },  // #5ec962
                { t: 1.0, c: [253, 231, 37] }   // #fde725
            ];
            
            for (let i = 0; i < stops.length - 1; i++) {
                if (t >= stops[i].t && t <= stops[i+1].t) {
                    const t0 = stops[i].t;
                    const t1 = stops[i+1].t;
                    const f = (t - t0) / (t1 - t0);
                    const c0 = stops[i].c;
                    const c1 = stops[i+1].c;
                    const r = c0[0] + (c1[0] - c0[0]) * f;
                    const g = c0[1] + (c1[1] - c0[1]) * f;
                    const b = c0[2] + (c1[2] - c0[2]) * f;
                    return new THREE.Color(r/255, g/255, b/255);
                }
            }
            return new THREE.Color(stops[stops.length-1].c[0]/255, stops[stops.length-1].c[1]/255, stops[stops.length-1].c[2]/255);
        }

        function buildHelix() {
            const roots = Object.keys(state.roots).sort(); // Alphabetical sort
            const totalRoots = roots.length;
            
            roots.forEach((rootStr, index) => {
                const angle = index * 0.5; // Spiral angle step
                const y = (index - totalRoots / 2) * HELIX_HEIGHT_STEP;
                const x = Math.cos(angle) * HELIX_RADIUS;
                const z = Math.sin(angle) * HELIX_RADIUS;

                // Gradient Color (Viridis)
                let val = index / totalRoots;
                let color = getViridisColor(val);

                // 3D Object (Glowing Sphere)
                const geometry = new THREE.SphereGeometry(0.8, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                
                // Store data in mesh
                mesh.userData = { type: 'root', root: rootStr, baseIndex: index, color: color };
                rootGroup.add(mesh);

                // Label
                const div = document.createElement('div');
                div.className = 'root-label';
                div.textContent = rootStr;
                div.style.setProperty('--root-color', '#' + color.getHexString());
                div.onclick = () => selectRoot(rootStr, mesh.position);
                
                const label = new CSS2DObject(div);
                label.position.set(0, 1, 0);
                mesh.add(label);

                state.objects.roots.push({ mesh, label, root: rootStr });
            });
        }

        function updateHelixInfinite() {
            if (state.objects.roots.length === 0) return;

            // Smooth scroll and rotation
            state.scrollY += (state.targetScrollY - state.scrollY) * 0.1;
            state.helixRotation += (state.targetHelixRotation - state.helixRotation) * 0.1;
            
            rootGroup.rotation.y = state.helixRotation;

            const totalRoots = state.objects.roots.length;
            const totalHeight = totalRoots * HELIX_HEIGHT_STEP;
            
            state.objects.roots.forEach(obj => {
                // 1. Calculate Linear Position relative to Center (0)
                // originalY is the absolute position in the helix
                const originalY = (obj.mesh.userData.baseIndex - totalRoots / 2) * HELIX_HEIGHT_STEP;
                
                // relativeY is distance from the current scroll center
                let relativeY = originalY - state.scrollY;

                // Wrap around for infinite scroll
                while (relativeY > totalHeight / 2) relativeY -= totalHeight;
                while (relativeY < -totalHeight / 2) relativeY += totalHeight;

                // 2. Apply Bubble Distortion (Fisheye on Y)
                // Expand space near 0
                const dist = Math.abs(relativeY);
                const sign = Math.sign(relativeY);
                
                // Distortion function: pushes items away from center
                // y_new = y + sign * strength * (1 - exp(-dist/radius)) * radius? 
                // No, simpler: y_new = y + sign * strength * smoothstep?
                // Let's use the exponential decay integral logic
                // We want density to be lower at 0.
                // y_distorted = y + sign * BUBBLE_STRENGTH * (1 - Math.exp(-dist / (BUBBLE_RADIUS/2))) * (BUBBLE_RADIUS/2);
                // Actually, let's just use a simple expansion factor that decays.
                
                let distortion = 0;
                if (dist < BUBBLE_RADIUS) {
                    // Calculate expansion
                    // We want to shift this item away from center
                    // The shift amount increases as we get further from center, then levels off?
                    // No, the shift amount is the integral of the expansion factor.
                    // Let's just use a direct mapping function.
                    // y' = y * (1 + factor * exp(-y^2)) is hard to invert/wrap?
                    // We don't need to invert. We just map relativeY -> screenY.
                    
                    // Simple "push away" logic
                    // Max push is at the edge of the bubble?
                    // Items at 0 stay at 0.
                    // Items at 10 move to 15.
                    // Items at 100 move to 130.
                    // Items at 1000 move to 1030 (constant offset).
                    
                    const maxShift = 60; // Max pixels to push away
                    const decay = 100;
                    distortion = sign * maxShift * (1 - Math.exp(-dist / decay));
                } else {
                    const maxShift = 60;
                    distortion = sign * maxShift * (1 - Math.exp(-BUBBLE_RADIUS / 100)); // Constant shift for items outside
                    // Actually, just use the formula for all items
                    distortion = sign * 60 * (1 - Math.exp(-dist / 100));
                }

                const finalY = relativeY + distortion;

                obj.mesh.position.y = finalY;

                // Update X/Z to maintain spiral based on VISUAL Y?
                // Or based on original index?
                // If we base it on finalY, the spiral stretches visually.
                // If we base it on original index, the spiral structure is rigid but items slide along it.
                // Sliding along rigid spiral is better for "beads on a string".
                // But we want the whole helix to inflate?
                // Let's try keeping X/Z fixed to the "slot" but the slot moves?
                // Actually, let's calculate angle based on the *undistorted* wrapped Y
                // so the spiral rotates naturally.
                
                // We need the continuous index that corresponds to relativeY
                // relativeY = (index - centerIndex) * STEP
                const continuousIndex = (relativeY + state.scrollY) / HELIX_HEIGHT_STEP + totalRoots/2;
                const angle = continuousIndex * 0.5;
                
                obj.mesh.position.x = Math.cos(angle) * HELIX_RADIUS;
                obj.mesh.position.z = Math.sin(angle) * HELIX_RADIUS;
                
                // Scale up items in the bubble
                const scale = 1 + 0.5 * Math.exp(-dist / 100);
                obj.mesh.scale.setScalar(scale);
                
                // Fade out items far away?
                const opacity = 1 - Math.min(1, (Math.abs(finalY) - 200) / 300);
                obj.mesh.material.opacity = Math.max(0.1, opacity);
                obj.mesh.material.transparent = true;
                
                // Hide label if too far
                if (Math.abs(finalY) > 300) {
                    obj.label.element.style.opacity = '0';
                    obj.label.element.style.pointerEvents = 'none';
                } else {
                    obj.label.element.style.opacity = '1';
                    obj.label.element.style.pointerEvents = 'auto';
                }
            });
        }

        function selectRoot(rootStr, position) {
            if (state.activeRoot === rootStr) return;
            state.activeRoot = rootStr;

            // Highlight Label
            state.objects.roots.forEach(obj => {
                if (obj.root === rootStr) obj.label.element.classList.add('active');
                else obj.label.element.classList.remove('active');
            });

            // Find the target root's base index
            const rootObj = state.objects.roots.find(o => o.root === rootStr);
            if (!rootObj) return;

            const totalRoots = state.objects.roots.length;
            const targetIndex = rootObj.mesh.userData.baseIndex;
            const currentCenterIndex = (state.targetScrollY / HELIX_HEIGHT_STEP) + totalRoots/2;
            
            // Calculate shortest path to target index (handling wrap)
            let diff = targetIndex - (currentCenterIndex % totalRoots);
            // Adjust for wrap
            if (diff > totalRoots / 2) diff -= totalRoots;
            if (diff < -totalRoots / 2) diff += totalRoots;
            
            // We want to scroll so that targetIndex is at the center (relativeY = 0)
            // state.scrollY corresponds to the Y value of the center.
            // The Y value of targetIndex is (targetIndex - totalRoots/2) * STEP.
            
            // But since we have infinite scroll, we just add the difference to current scrollY
            // Actually, let's just set targetScrollY.
            // We need to calculate the Y position of the target *relative to current scroll*
            // and add that to current scroll.
            
            // Simpler:
            // The target Y is (targetIndex - totalRoots/2) * STEP.
            // But we can add multiples of totalHeight to minimize travel.
            const totalHeight = totalRoots * HELIX_HEIGHT_STEP;
            const targetBaseY = (targetIndex - totalRoots / 2) * HELIX_HEIGHT_STEP;
            
            // Find k such that targetBaseY + k*totalHeight is closest to state.scrollY
            const k = Math.round((state.scrollY - targetBaseY) / totalHeight);
            const targetY = targetBaseY + k * totalHeight;
            
            state.targetScrollY = targetY;

            // Expand Satellites
            const rootColor = rootObj.mesh.userData.color;
            spawnSatellites(rootStr, rootObj.mesh, rootColor);
        }

        function spawnSatellites(rootStr, rootMesh, rootColor) {
            // Clear existing satellites
            const layer = document.getElementById('satellite-layer');
            layer.innerHTML = '';
            state.objects.satellites = [];

            const verbs = state.roots[rootStr];
            const count = verbs.length;

            // 2D Layout Parameters
            const ySpacing = 60; // Vertical spacing between verbs (tighter)
            
            verbs.forEach((verb, i) => {
                // Calculate offset relative to root center
                // Center the stack vertically
                const yOffset = (i - (count - 1) / 2) * ySpacing;
                
                // Verb Node (Standard DOM element)
                const div = document.createElement('div');
                div.className = 'verb-label satellite-item';
                div.style.borderColor = '#' + rootColor.getHexString();
                div.style.boxShadow = `0 0 10px #${rootColor.getHexString()}`;
                
                // Click on container does nothing (buttons handle actions)
                div.onclick = (e) => e.stopPropagation();
                
                layer.appendChild(div);

                state.objects.satellites.push({ 
                    element: div, 
                    verb, 
                    targetMesh: rootMesh,
                    yOffset: yOffset // Only Y offset matters now
                });
            });

            updateSatelliteLabels();
        }

        function updateSatellites() {
            if (state.objects.satellites.length === 0) return;

            // We need to find the screen Y of the target mesh
            // Since all satellites share the same targetMesh (the active root),
            // we can calculate it once.
            const firstSat = state.objects.satellites[0];
            if (!firstSat.targetMesh) return;

            const vector = new THREE.Vector3();
            firstSat.targetMesh.getWorldPosition(vector);
            
            // Project to screen space
            vector.project(camera);
            
            // Convert NDC to pixel coordinates
            // Y is inverted in CSS (0 is top)
            const screenY = (-(vector.y) * 0.5 + 0.5) * window.innerHeight;
            
            // Check if root is roughly on screen
            const isVisible = (screenY > -100 && screenY < window.innerHeight + 100);
            
            state.objects.satellites.forEach(obj => {
                if (!isVisible) {
                    obj.element.style.display = 'none';
                } else {
                    obj.element.style.display = 'flex';
                    // Apply vertical offset
                    // Note: yOffset is in pixels? No, it was in 3D units before.
                    // We should treat yOffset as pixels now for the UI layer.
                    // Let's assume yOffset is pixels.
                    
                    const finalY = screenY + obj.yOffset;
                    obj.element.style.top = `${finalY}px`;
                    // Centering the element itself
                    obj.element.style.transform = `translateY(-50%)`;
                }
            });
        }

        function updateSatelliteLabels() {
            state.objects.satellites.forEach(obj => {
                const verb = obj.verb;
                const div = obj.element;
                
                let text = '';
                let sub = verb.bnE; // Binyan as subtitle
                let audioPath = null;

                if (state.tense === 'inf') {
                    text = verb.inf;
                    // Find audio for infinitive
                    if (verb.conjugations && verb.conjugations.inf && verb.conjugations.inf[0]) {
                        audioPath = verb.conjugations.inf[0].aud;
                    }
                } else {
                    // Look up conjugation
                    const forms = verb.conjugations ? verb.conjugations[state.tense] : null;
                    if (forms) {
                        // Find form matching current pronoun
                        // Note: Imperative doesn't have all pronouns, Future/Past do.
                        // We need to map UI pronoun to Data pronoun.
                        const match = forms.find(f => f.prn === state.pronoun);
                        if (match) {
                            text = match.frm; // The Hebrew word
                            sub = match.trl;  // Transliteration
                            audioPath = match.aud;
                        } else {
                            text = '-';
                            sub = 'N/A';
                        }
                    } else {
                        text = '-';
                        sub = 'No Data';
                    }
                }

                div.innerHTML = `
                    <div style="font-size: 1.2em; font-weight: bold;">${text}</div>
                    <div class="verb-sub">
                        ${sub}
                        <button class="info-btn" title="Show Info">癸</button>
                    </div>
                `;
                
                // Click on main div -> Play Audio
                div.onclick = (e) => {
                    e.stopPropagation();
                    if (audioPath) playAudio(audioPath);
                };

                // Info Button
                const infoBtn = div.querySelector('.info-btn');
                if (infoBtn) {
                    infoBtn.onclick = (e) => {
                        e.stopPropagation();
                        showVerbInfo(verb);
                    };
                }
            });
        }

        function showVerbInfo(verb) {
            const panel = document.getElementById('info-panel');
            const content = document.getElementById('panel-content');
            
            let html = `
                <h2>${verb.inf}</h2>
                <p style="color: #aaa;">${verb.mng.join(', ')}</p>
                <hr style="border-color: #333;">
                <div style="margin-bottom: 10px;">
                    <strong>Root:</strong> ${verb.rt.join('.')}<br>
                    <strong>Binyan:</strong> ${verb.bn} (${verb.bnE})
                </div>
            `;

            // Examples
            if (verb.examples && verb.examples.length > 0) {
                html += `<h3>Examples</h3>`;
                verb.examples.forEach(ex => {
                    let exAudio = ex.audio ? '../../' + ex.audio : null;
                    html += `
                        <div style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                            <div style="display:flex; justify-content:space-between;">
                                <span style="font-size: 1.1em; direction: rtl;">${ex.hebrew}</span>
                                ${exAudio ? `<button onclick="playAudio('${exAudio}')" style="background:none; border:none; cursor:pointer;"></button>` : ''}
                            </div>
                            ${ex.transliteration ? `<div style="color: #888; font-size: 0.9em;">${ex.transliteration}</div>` : ''}
                            <div style="font-style: italic;">${ex.translation}</div>
                        </div>
                    `;
                });
            }

            content.innerHTML = html;
            panel.classList.add('visible');
        }

        window.playAudio = function(path) {
            // Fix path if needed
            if (path.startsWith('audio/')) path = '../../' + path.replace('.wav', '.mp4');
            
            const audio = new Audio(path);
            audio.play().catch(e => console.warn("Audio play failed", e));
        }

        function setupUI() {
            const tenseSelect = document.getElementById('tense-select');
            const pronounSelect = document.getElementById('pronoun-select');

            tenseSelect.addEventListener('change', (e) => {
                state.tense = e.target.value;
                // Enable/Disable pronoun select based on tense
                if (state.tense === 'inf') {
                    pronounSelect.disabled = true;
                } else {
                    pronounSelect.disabled = false;
                }
                updateSatelliteLabels();
            });

            pronounSelect.addEventListener('change', (e) => {
                state.pronoun = e.target.value;
                updateSatelliteLabels();
            });
        }

        function performSearch(query) {
            if (!query) return;
            const q = query.toLowerCase().trim();
            
            // 1. Search Roots
            // Try exact match first, then partial
            let rootMatch = Object.keys(state.roots).find(r => r.toLowerCase() === q || r.replace(/\./g, '').toLowerCase() === q);
            if (!rootMatch) {
                rootMatch = Object.keys(state.roots).find(r => r.toLowerCase().includes(q) || r.replace(/\./g, '').toLowerCase().includes(q));
            }

            if (rootMatch) {
                const obj = state.objects.roots.find(o => o.root === rootMatch);
                if (obj) {
                    selectRoot(rootMatch, obj.mesh.position);
                    return;
                }
            }

            // 2. Search Verbs (Infinitive or Meaning)
            for (const root in state.roots) {
                const verbs = state.roots[root];
                const verbMatch = verbs.find(v => 
                    v.inf.includes(q) || 
                    (v.mng && v.mng.some(m => m.toLowerCase().includes(q)))
                );
                
                if (verbMatch) {
                    const obj = state.objects.roots.find(o => o.root === root);
                    if (obj) {
                        selectRoot(root, obj.mesh.position);
                        // Ideally we would highlight the specific verb satellite too, 
                        // but selectRoot respawns them. 
                        // We could pass a target verb to selectRoot?
                        // For now, just going to the root is a huge improvement.
                        return;
                    }
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            // controls.update(); // Removed
            updateHelixInfinite();
            updateSatellites();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        // --- Input Handling ---

        function onPointerDown(event) {
            if (event.target.closest('#ui-layer')) return;
            if (!event.isPrimary) return; // Only track primary pointer
            
            state.isDragging = true;
            state.lastMouseX = event.clientX;
            state.lastMouseY = event.clientY;

            // Raycast for selection
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(rootGroup.children);
            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.type === 'root') {
                    selectRoot(object.userData.root, object.position);
                }
            }
        }

        function onPointerMove(event) {
            if (!event.isPrimary) return;
            if (!state.isDragging) return;

            const deltaX = event.clientX - state.lastMouseX;
            const deltaY = event.clientY - state.lastMouseY;

            state.lastMouseX = event.clientX;
            state.lastMouseY = event.clientY;

            // Horizontal Drag -> Rotate Helix
            state.targetHelixRotation += deltaX * 0.005;

            // Vertical Drag -> Scroll
            state.targetScrollY -= deltaY * 0.5;
        }

        function onPointerUp(event) {
            if (!event.isPrimary) return;
            state.isDragging = false;
        }

        function onWheel(event) {
            // Wheel -> Scroll
            state.targetScrollY += event.deltaY * 0.1;
        }
    </script>
</body>
</html>
