<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hebrew Text Writer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        #ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px;
            pointer-events: auto;
            display: flex; flex-direction: column; gap: 10px;
            min-width: 300px;
        }
        input, button { 
            background: #333; color: white; padding: 8px; 
            border: 1px solid #555; font-size: 1em; border-radius: 4px;
        }
        button:hover { background: #444; cursor: pointer; }
        #status { font-size: 0.9em; color: #aaa; margin-top: 5px; }
    </style>
</head>
<body>
    <div id="ui">
        <h3>Hebrew Text Writer</h3>
        <input type="text" id="text-input" placeholder="Enter Hebrew Text..." dir="rtl" value="שלום">
        <button id="btn-write">Write</button>
        
        <div style="border-top: 1px solid #444; margin-top: 5px; padding-top: 10px; display: flex; flex-direction: column; gap: 8px; font-size: 0.9em;">
            <label style="display: flex; justify-content: space-between; align-items: center;">
                Size: <input type="number" id="setting-size" value="0.3" step="0.1" min="0.1" max="2.0" style="width: 60px;">
            </label>
            <label style="display: flex; justify-content: space-between; align-items: center;">
                Stroke: <input type="number" id="setting-stroke" value="2" step="1" min="1" max="10" style="width: 60px;">
            </label>
            <label style="display: flex; justify-content: space-between; align-items: center;">
                Color: <input type="color" id="setting-color" value="#4db8ff" style="height: 30px; width: 60px; padding: 0;">
            </label>
            <label style="display: flex; justify-content: space-between; align-items: center;">
                Background: <input type="color" id="setting-bg" value="#111111" style="height: 30px; width: 60px; padding: 0;">
            </label>
        </div>

        <div id="status">Loading font data...</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

        let scene, camera, renderer, controls;
        let letterData = {};
        
        let animationQueue = [];
        let isAnimating = false;
        let animationStartTime = 0;
        const DRAW_SPEED = 0.1; // Units per ms (adjust for speed)
        
        // Hebrew Char to Name mapping
        const charMap = {
            'א': 'Aleph',
            'ב': 'Bet', // Default to Bet, logic might need to handle Vet if distinct in input or context
            'ג': 'Gimmel',
            'ד': 'Dalet',
            'ה': 'Hei',
            'ו': 'Vav',
            'ז': 'Zayin',
            'ח': 'Het',
            'ט': 'Tet',
            'י': 'Yud',
            'כ': 'Kaf',
            'ך': 'Final Kaf',
            'ל': 'Lamed',
            'מ': 'Mem',
            'ם': 'Final Mem',
            'נ': 'Nun',
            'ן': 'Final Nun',
            'ס': 'Samech',
            'ע': 'Ayin',
            'פ': 'Pei',
            'ף': 'Final Pei',
            'צ': 'Tzadi',
            'ץ': 'Final Tzadi',
            'ק': 'Kuf',
            'ר': 'Resh',
            'ש': 'Shin', // Default to Shin, Sin handling might be needed
            'ת': 'Tav'
        };

        init();

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 200;
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.enableRotate = false; // 2D view

            // Grid
            const grid = new THREE.GridHelper(500, 50, 0x333333, 0x222222);
            grid.rotation.x = Math.PI / 2;
            scene.add(grid);

            window.addEventListener('resize', onWindowResize);

            // Load Data
            try {
                const res = await fetch('/api/letters');
                if (res.ok) {
                    letterData = await res.json();
                    document.getElementById('status').textContent = "Ready";
                } else {
                    // Fallback to local if API fails (dev mode)
                    const localRes = await fetch('../hebrew_script_writer/images/letters.json');
                    if (localRes.ok) {
                        letterData = await localRes.json();
                        document.getElementById('status').textContent = "Ready (Local Data)";
                    } else {
                        document.getElementById('status').textContent = "Error loading font data";
                    }
                }
            } catch (e) {
                console.error(e);
                document.getElementById('status').textContent = "Error loading data";
            }

            document.getElementById('btn-write').onclick = writeText;
            
            // Background setting
            document.getElementById('setting-bg').addEventListener('input', (e) => {
                scene.background = new THREE.Color(e.target.value);
            });
            
            animate();
        }

        function writeText() {
            let text = document.getElementById('text-input').value;
            // Strip Nikkud (Hebrew vowels/diacritics)
            text = text.replace(/[\u0591-\u05C7]/g, '');

            if (!text) return;

            // Clear previous
            scene.children = scene.children.filter(c => c.type !== 'Group'); // Keep grid/lights if any
            animationQueue = [];
            isAnimating = false;

            const group = new THREE.Group();
            scene.add(group);

            let cursorX = 0;
            
            // Settings
            const textSize = parseFloat(document.getElementById('setting-size').value) || 0.3;
            const strokeWidth = parseFloat(document.getElementById('setting-stroke').value) || 2;
            const strokeColor = document.getElementById('setting-color').value || '#4db8ff';
            
            const baseSpacing = 100 * textSize; 
            
            // Calculate total width for centering
            let totalWidth = 0;
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const name = charMap[char];
                let width = 1.0;
                if (name && letterData[name]) {
                    const data = letterData[name];
                    if (data.width) width = data.width;
                    else if (Array.isArray(data)) width = 1.0;
                }
                if (char === ' ') width = 0.5;
                totalWidth += width * baseSpacing;
            }
            
            cursorX = totalWidth / 2; // Start from right

            let currentStartTime = 0;

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const name = charMap[char];
                
                let width = 1.0;
                let startX = 0.0;
                let strokesData = null;

                if (name && letterData[name]) {
                    const data = letterData[name];
                    if (Array.isArray(data)) {
                        // Old format
                        strokesData = data;
                    } else if (data.strokes) {
                        // New format
                        strokesData = data.strokes;
                        if (data.width) width = data.width;
                        if (data.startX) startX = data.startX;
                    }
                }
                
                if (strokesData) {
                    // Position logic (RTL):
                    // cursorX is the Right boundary of the current character slot.
                    // startX is the offset of the Right boundary from the character origin (local 0,0).
                    // So: World_Right_Boundary = World_Origin + startX * spacing
                    // We want World_Right_Boundary = cursorX
                    // So: World_Origin = cursorX - startX * spacing
                    
                    const letterX = cursorX - startX * baseSpacing;
                    
                    const letterObj = createLetterMesh(strokesData, textSize, strokeWidth, strokeColor);
                    letterObj.position.x = letterX;
                    group.add(letterObj);
                    
                    // Calculate duration based on total length of strokes
                    let totalLength = 0;
                    letterObj.children.forEach(line => {
                        if (line.userData.length) totalLength += line.userData.length;
                    });
                    
                    // Scale length by mesh scale (textSize) to get visual length
                    const visualLength = totalLength * textSize;
                    const duration = visualLength / DRAW_SPEED;

                    // Add to animation queue
                    animationQueue.push({
                        obj: letterObj,
                        startTime: currentStartTime,
                        duration: duration,
                        strokes: letterObj.children.map(line => ({
                            line: line,
                            length: line.userData.length * textSize // Visual length
                        }))
                    });
                    
                    currentStartTime += duration;
                } else if (char === ' ') {
                    width = 0.5;
                    // Add a small pause for space?
                    currentStartTime += 200;
                }
                
                cursorX -= width * baseSpacing;
            }
            
            if (animationQueue.length > 0) {
                isAnimating = true;
                animationStartTime = performance.now();
            }
        }

        function createLetterMesh(strokesData, scale, linewidth, color) {
            const letterGroup = new THREE.Group();
            
            strokesData.forEach(strokePoints => {
                if (strokePoints.length < 2) return;
                
                const points = strokePoints.map(p => new THREE.Vector3(p[0], p[1], 0));
                const curve = new THREE.CatmullRomCurve3(points, false, 'centripetal', 0.5);
                const totalPoints = 100;
                const curvePoints = curve.getSpacedPoints(totalPoints);
                
                // Convert to flat array for LineGeometry
                const positions = [];
                curvePoints.forEach(p => positions.push(p.x, p.y, p.z));
                
                const geometry = new LineGeometry();
                geometry.setPositions(positions);
                
                const material = new LineMaterial({ 
                    color: color, 
                    linewidth: linewidth, // in pixels
                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),
                    dashed: false,
                    alphaToCoverage: true,
                });
                
                const line = new Line2(geometry, material);
                line.computeLineDistances();
                line.scale.set(scale, scale, scale);
                
                // Hide initially (instanceCount = 0)
                geometry.instanceCount = 0;
                
                // Store metadata for animation
                line.userData = { 
                    totalSegments: totalPoints, // actually totalPoints segments roughly (points-1)
                    length: curve.getLength()
                };
                
                letterGroup.add(line);
            });

            return letterGroup;
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 200;
            camera.left = -frustumSize * aspect / 2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = -frustumSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Update resolution for all Line2 materials
            scene.traverse(obj => {
                if (obj.isLine2 && obj.material) {
                    obj.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (isAnimating) {
                const now = performance.now();
                const totalElapsed = now - animationStartTime;
                let allDone = true;
                
                animationQueue.forEach(item => {
                    const itemElapsed = totalElapsed - item.startTime;
                    const strokes = item.strokes;
                    
                    if (itemElapsed < 0) {
                        // Not started yet
                        strokes.forEach(s => s.line.geometry.instanceCount = 0);
                        allDone = false;
                    } else if (itemElapsed < item.duration) {
                        // In progress - Consecutive Strokes based on length
                        let currentDist = itemElapsed * DRAW_SPEED;
                        
                        strokes.forEach(s => {
                            if (currentDist >= s.length) {
                                // Finished this stroke
                                s.line.geometry.instanceCount = s.line.userData.totalSegments;
                                currentDist -= s.length;
                            } else if (currentDist > 0) {
                                // Drawing this stroke
                                const progress = currentDist / s.length;
                                const count = Math.floor(progress * s.line.userData.totalSegments);
                                s.line.geometry.instanceCount = count;
                                currentDist = 0; // Consumed all distance
                            } else {
                                // Not reached yet
                                s.line.geometry.instanceCount = 0;
                            }
                        });
                        allDone = false;
                    } else {
                        // Finished
                        strokes.forEach(s => {
                            s.line.geometry.instanceCount = s.line.userData.totalSegments;
                        });
                    }
                });
                
                // Check if the last item is finished
                if (animationQueue.length > 0) {
                    const lastItem = animationQueue[animationQueue.length - 1];
                    if (totalElapsed > lastItem.startTime + lastItem.duration) {
                        isAnimating = false;
                    }
                } else {
                    isAnimating = false;
                }
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
