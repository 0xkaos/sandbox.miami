<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hebrew Text Writer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        #ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px;
            pointer-events: auto;
            display: flex; flex-direction: column; gap: 10px;
            min-width: 300px;
        }
        input, button { 
            background: #333; color: white; padding: 8px; 
            border: 1px solid #555; font-size: 1em; border-radius: 4px;
        }
        button:hover { background: #444; cursor: pointer; }
        #status { font-size: 0.9em; color: #aaa; margin-top: 5px; }
    </style>
</head>
<body>
    <div id="ui">
        <h3>Hebrew Text Writer</h3>
        <input type="text" id="text-input" placeholder="Enter Hebrew Text..." dir="rtl" value="שלום">
        <button id="btn-write">Write</button>
        <div id="status">Loading font data...</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let letterData = {};
        
        // Hebrew Char to Name mapping
        const charMap = {
            'א': 'Aleph',
            'ב': 'Bet', // Default to Bet, logic might need to handle Vet if distinct in input or context
            'ג': 'Gimmel',
            'ד': 'Dalet',
            'ה': 'Hei',
            'ו': 'Vav',
            'ז': 'Zayin',
            'ח': 'Het',
            'ט': 'Tet',
            'י': 'Yud',
            'כ': 'Kaf',
            'ך': 'Final Kaf',
            'ל': 'Lamed',
            'מ': 'Mem',
            'ם': 'Final Mem',
            'נ': 'Nun',
            'ן': 'Final Nun',
            'ס': 'Samech',
            'ע': 'Ayin',
            'פ': 'Pei',
            'ף': 'Final Pei',
            'צ': 'Tzadi',
            'ץ': 'Final Tzadi',
            'ק': 'Kuf',
            'ר': 'Resh',
            'ש': 'Shin', // Default to Shin, Sin handling might be needed
            'ת': 'Tav'
        };

        init();

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 200;
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.enableRotate = false; // 2D view

            // Grid
            const grid = new THREE.GridHelper(500, 50, 0x333333, 0x222222);
        let animationQueue = [];
        let isAnimating = false;
        let animationStartTime = 0;
        const LETTER_DURATION = 1000; // ms per letter

        // Widths for kerning (approximate, relative to standard spacing)
        const charWidths = {
            'Vav': 0.4, 'Zayin': 0.5, 'Yud': 0.3, 'Nun': 0.5, 'Final Nun': 0.4,
            'Gimmel': 0.6, 'Final Kaf': 0.6, 'Final Pei': 0.6, 'Final Tzadi': 0.6,
            'Shin': 1.1, 'Tet': 1.1, 'Samech': 1.0, 'Mem': 1.1
        };

        init();

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 200;
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.enableRotate = false; // 2D view

            // Grid
            const grid = new THREE.GridHelper(500, 50, 0x333333, 0x222222);
            grid.rotation.x = Math.PI / 2;
            scene.add(grid);

            window.addEventListener('resize', onWindowResize);

            // Load Data
            try {
                const res = await fetch('/api/letters');
                if (res.ok) {
                    letterData = await res.json();
                    document.getElementById('status').textContent = "Ready";
                } else {
                    // Fallback to local if API fails (dev mode)
                    const localRes = await fetch('../hebrew_script_writer/images/letters.json');
                    if (localRes.ok) {
                        letterData = await localRes.json();
                        document.getElementById('status').textContent = "Ready (Local Data)";
                    } else {
                        document.getElementById('status').textContent = "Error loading font data";
                    }
                }
            } catch (e) {
                console.error(e);
                document.getElementById('status').textContent = "Error loading data";
            }

            document.getElementById('btn-write').onclick = writeText;
            
            animate();
        }

        function writeText() {
            const text = document.getElementById('text-input').value;
            if (!text) return;

            // Clear previous
            scene.children = scene.children.filter(c => c.type !== 'Group'); // Keep grid/lights if any
            animationQueue = [];
            isAnimating = false;

            const group = new THREE.Group();
            scene.add(group);

            let cursorX = 0;
            const baseSpacing = 40; 
            
            // Calculate total width for centering
            let totalWidth = 0;
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const name = charMap[char];
                let width = 1.0;
                if (name && charWidths[name]) width = charWidths[name];
                if (char === ' ') width = 0.5;
                totalWidth += width * baseSpacing;
            }
            
            cursorX = totalWidth / 2; // Start from right

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const name = charMap[char];
                
                let width = 1.0;
                if (name && charWidths[name]) width = charWidths[name];
                
                if (name && letterData[name]) {
                    // Center the letter in its allocated space
                    // Standard letter is roughly centered at 0 in local coords
                    // We move cursor left by width*spacing
                    // Letter position should be cursorX - (width*spacing)/2
                    
                    const letterX = cursorX - (width * baseSpacing) / 2;
                    
                    const letterObj = createLetterMesh(letterData[name]);
                    letterObj.position.x = letterX;
                    group.add(letterObj);
                    
                    // Add to animation queue
                    animationQueue.push({
                        obj: letterObj,
                        startTime: i * LETTER_DURATION,
                        duration: LETTER_DURATION
                    });
                } else if (char === ' ') {
                    width = 0.5;
                }
                
                cursorX -= width * baseSpacing;
            }
            
            if (animationQueue.length > 0) {
                isAnimating = true;
                animationStartTime = performance.now();
            }
        }

        function createLetterMesh(strokesData) {
            const letterGroup = new THREE.Group();
            
            strokesData.forEach(strokePoints => {
                if (strokePoints.length < 2) return;
                
                const points = strokePoints.map(p => new THREE.Vector3(p[0], p[1], 0));
                const curve = new THREE.CatmullRomCurve3(points, false, 'centripetal', 0.5);
                const totalPoints = 100;
                const geometry = new THREE.BufferGeometry().setFromPoints(curve.getSpacedPoints(totalPoints));
                const material = new THREE.LineBasicMaterial({ color: 0x4db8ff, linewidth: 2 });
                const line = new THREE.Line(geometry, material);
                
                line.scale.set(0.3, 0.3, 0.3);
                
                // Hide initially
                geometry.setDrawRange(0, 0);
                
                // Store metadata for animation
                line.userData = { totalPoints: totalPoints };
                
                letterGroup.add(line);
            });

            return letterGroup;
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 200;
            camera.left = -frustumSize * aspect / 2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = -frustumSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (isAnimating) {
                const now = performance.now();
                const totalElapsed = now - animationStartTime;
                let allDone = true;
                
                animationQueue.forEach(item => {
                    const itemElapsed = totalElapsed - item.startTime;
                    
                    if (itemElapsed < 0) {
                        // Not started yet
                        item.obj.children.forEach(line => line.geometry.setDrawRange(0, 0));
                        allDone = false;
                    } else if (itemElapsed < item.duration) {
                        // In progress
                        const progress = itemElapsed / item.duration;
                        item.obj.children.forEach(line => {
                            const count = Math.floor(progress * line.userData.totalPoints);
                            line.geometry.setDrawRange(0, count);
                        });
                        allDone = false;
                    } else {
                        // Finished
                        item.obj.children.forEach(line => {
                            line.geometry.setDrawRange(0, Infinity);
                        });
                    }
                });
                
                if (allDone && animationQueue.length > 0 && totalElapsed > animationQueue[animationQueue.length-1].startTime + LETTER_DURATION) {
                    isAnimating = false;
                }
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
