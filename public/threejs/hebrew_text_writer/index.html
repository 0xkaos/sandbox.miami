<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hebrew Text Writer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        #ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px;
            pointer-events: auto;
            display: flex; flex-direction: column; gap: 10px;
            min-width: 300px;
        }
        input, button { 
            background: #333; color: white; padding: 8px; 
            border: 1px solid #555; font-size: 1em; border-radius: 4px;
        }
        button:hover { background: #444; cursor: pointer; }
        #status { font-size: 0.9em; color: #aaa; margin-top: 5px; }
    </style>
</head>
<body>
    <div id="ui">
        <h3>Hebrew Text Writer</h3>
        <input type="text" id="text-input" placeholder="Enter Hebrew Text..." dir="rtl" value="שלום">
        <button id="btn-write">Write</button>
        <div id="status">Loading font data...</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let letterData = {};
        
        // Hebrew Char to Name mapping
        const charMap = {
            'א': 'Aleph',
            'ב': 'Bet', // Default to Bet, logic might need to handle Vet if distinct in input or context
            'ג': 'Gimmel',
            'ד': 'Dalet',
            'ה': 'Hei',
            'ו': 'Vav',
            'ז': 'Zayin',
            'ח': 'Het',
            'ט': 'Tet',
            'י': 'Yud',
            'כ': 'Kaf',
            'ך': 'Final Kaf',
            'ל': 'Lamed',
            'מ': 'Mem',
            'ם': 'Final Mem',
            'נ': 'Nun',
            'ן': 'Final Nun',
            'ס': 'Samech',
            'ע': 'Ayin',
            'פ': 'Pei',
            'ף': 'Final Pei',
            'צ': 'Tzadi',
            'ץ': 'Final Tzadi',
            'ק': 'Kuf',
            'ר': 'Resh',
            'ש': 'Shin', // Default to Shin, Sin handling might be needed
            'ת': 'Tav'
        };

        init();

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 200;
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.enableRotate = false; // 2D view

            // Grid
            const grid = new THREE.GridHelper(500, 50, 0x333333, 0x222222);
            grid.rotation.x = Math.PI / 2;
            scene.add(grid);

            window.addEventListener('resize', onWindowResize);

            // Load Data
            try {
                const res = await fetch('/api/letters');
                if (res.ok) {
                    letterData = await res.json();
                    document.getElementById('status').textContent = "Ready";
                } else {
                    // Fallback to local if API fails (dev mode)
                    const localRes = await fetch('../hebrew_script_writer/images/letters.json');
                    if (localRes.ok) {
                        letterData = await localRes.json();
                        document.getElementById('status').textContent = "Ready (Local Data)";
                    } else {
                        document.getElementById('status').textContent = "Error loading font data";
                    }
                }
            } catch (e) {
                console.error(e);
                document.getElementById('status').textContent = "Error loading data";
            }

            document.getElementById('btn-write').onclick = writeText;
            
            animate();
        }

        function writeText() {
            const text = document.getElementById('text-input').value;
            if (!text) return;

            // Clear previous
            scene.children = scene.children.filter(c => c.type !== 'Group'); // Keep grid/lights if any

            const group = new THREE.Group();
            scene.add(group);

            let cursorX = 0;
            const spacing = 40; // Adjust based on letter size

            // Process text right-to-left visually, but string is logical
            // Hebrew is RTL. If we draw from right to left:
            // Start cursor at some positive X and move left (negative X)
            
            cursorX = (text.length * spacing) / 2; // Center roughly

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const name = charMap[char];
                
                if (name && letterData[name]) {
                    const letterMesh = createLetterMesh(letterData[name]);
                    letterMesh.position.x = cursorX;
                    group.add(letterMesh);
                } else if (char === ' ') {
                    // Space
                } else {
                    console.warn("Unknown char:", char);
                }
                
                cursorX -= spacing;
            }
        }

        function createLetterMesh(strokesData) {
            const letterGroup = new THREE.Group();
            
            strokesData.forEach(strokePoints => {
                if (strokePoints.length < 2) return;
                
                const points = strokePoints.map(p => new THREE.Vector3(p[0], p[1], 0));
                const curve = new THREE.CatmullRomCurve3(points, false, 'centripetal', 0.5);
                const geometry = new THREE.BufferGeometry().setFromPoints(curve.getSpacedPoints(50));
                const material = new THREE.LineBasicMaterial({ color: 0x4db8ff, linewidth: 2 });
                const line = new THREE.Line(geometry, material);
                
                // Scale down? The editor scale was quite large (-100 to 100 approx)
                // Let's scale it down to be reasonable
                line.scale.set(0.3, 0.3, 0.3);
                
                letterGroup.add(line);
            });

            return letterGroup;
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 200;
            camera.left = -frustumSize * aspect / 2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = -frustumSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
